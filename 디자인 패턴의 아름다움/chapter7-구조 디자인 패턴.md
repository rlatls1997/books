# Chapter 7. 구조 디자인 패턴
응용프로그램 시나리오의 문제를 해결하는데 사용되는 클래스나 객체의 고전적인 구조를 모아둔 것


## 7.1 프록세 패턴
프록시 패턴 : 원본 클래스를 변경하지 않은 상태로 프록시 클래스를 도입하여 원본 클래스와 관련 없는 새로운 기능을 추가하는 것

### 1. 인터페이스 기반의 프록시 패턴
**구현 방법**
1. 원본 클래스와 프록시 클래스 모두 같은 인터페이스를 구현한다.
2. 프록시 클래스에서 원본 클래스 의존성을 갖는다.
3. 프록시 클래스 메서드 오버라이딩에서 원본 클래스의 구현 메서드를 호출한다.

### 2. 상속 기반의 프록시 패턴
상속을 사용하여 외부 클래스를 확장한다.

## 3. 리플렉션 기반의 동적 프록시
인터페이스, 상속 기반의 코드는 각 메서드마다 유사한 코드 논리를 첨부해야한다.
또한 기능을 추가해야하는 클래스가 많으면 각 클래스 모드에 대해 프록시 클래스를 생성해야한다.

`동적 프록시`를 사용하여 각 원본 클래스에 대한 프록시 클래스를 작성하는 대신 실행하는 도중 원본 클래스에 대한 프록시 클래스를 생성하고, 코드 내의 원본 클래스를 프록시 클래스로 대체할 수 있다.
ex) Spring AOP, (트랜잭션도 프록시 방식으로 동작하는걸로 앎)

### 4. 프록시 패턴의 활용 방법
프록시 패턴의 기본 기능은 원본 클래스와 관련이 없는 기능을 추가하는 것.

비즈니스와 관련 없는 요구사항을 개발하는 데에 적용할 수 있다.

## 7.2 데커레이터 패턴
### 1 Java IO 라이브러리의 특이한 사용법
```java
InputStream in = new FileInputStream("test.txt");
InputStream bin = new BufferedInputStream(in);
byte[] data = new byte[128];
        ...
```
왜 FileInputStream클래스를 확장하여 BufferedinputStream을 만들지 않았을까?

### 2. 상속 기반 설계
BufferedinputStream는 합성을 하도록 설계되었다.
InputStream클래스에는 수많은 하쉬 클래스가 존재하기 때문이다.

### 3. 데커레이터 패턴 기반 설계 계획
상속을 합성으로 대체하는 것이 꼭 데커레이터 패턴은 아니다.

데커레이터 패턴과 합성은 차이가 있다.
1. 데커레이터 클래스가 원본 클래스와 동일한 상위 클래스를 상속하기 때문에 원본 클래스 내에 여거개의 데커레이터 클래스를 중첩할 수 있다.
2. 데커레이터 크랠스의 기능은 원본 클래스의 기능을 향상시키는 것이다.

데커레이터 패턴을 통해 복잡한 상속 문제를 해결하고 상속 관계를 합성으로 대체할 수 있다.

## 7.3 어댑터 패턴
클래스 어댑터와 객체 어댑터가 있다.
ex) SLF4J 로깅 프레임워크

### 1. 클래스 어댑터와 객체 어댑터
어댑터 패턴 : 호환되지 않는 인터페이스를 호환 가능한 인터페이스로 변환하여 두 클래스를 함께 작동할 수 있게 함.

- 클래스 어댑터 : 상속 관계를 사용한 방식
- 객체 어댑터 : 합성 관계를 사용한 방식

**상속 기반의 클래스 어댑터 구현**
1. 호환할 인터페이스를 구현하고 대상 클래스를 확장한 어댑터 클래스를 생성한다
2. 인터페이스 구현 메서드에서 확장한 어댑터 클래스에서 대상 클래스의 메서드를 호출한다.

**합성 기반의 객체 어댑터**
1. 호환할 인터페이스를 구현하고 대상 클래스를 합성(composition)한다.
2. 인터페이스 구현 메서드에서 멤버로 갖고 있는 대상 클래스의 메서드를 호출한다.

둘 중 어떤 방식을 선택해야하나?
- 대상클래스의 인터페이스(메서드)가 많지 않다면 뭐든 ok
- 대상 클래스와 호환할 인터페이스의 정의가 대부분 같다면 클래스 어댑터
- 정의가 대부분 다르다면 객체 어댑터

### 2. 어댑터 패턴의 응용
어댑터 패턴은 `인터페이스의 비호환성`에서 비롯된다.

**인터페이스가 호환되지 않게 되는 예**
- 결함이 있는 인터페이스 설계가 캡술화된 경우
- 여러 클래스의 인터페이스 설계를 통합할 경우
- 사용중인 외부 시스템을 교체해야 할 경우
- 이전 버전 인터페이스와 호환성이 필요한 경우
- 다양한 형식의 데이터에 적응해야 할 경우

### 3. 자바 로깅과 어댑터 패턴
### 4. 래퍼 패턴
프록시 패턴, 데커레이터 패턴, 어댑터 패턴은 유사하지만 적용할 시나리오가 다르다.
코드 구조 측면에서 이 세가지 디자인 패턴을 래퍼 패턴으로 구분한다.

## 7.4 브리지 패턴
### 1. 브리지 패턴의 정의
클래스에는 독립적으로 변하는 두 개 또는 그 이상의 차원이 존재하고, 합성 메서드를 통해 이 클래스를 두 개 또는 그 이상의 차원에서 확장할 수 있다(?)

### 2. 브리지 패턴으로 폭발적인 상속 해결하기
차를 선택할 때 선루프의 종류를 N, 허브의 종류를 M이라고 하자
차 class를 구현할 때 상속 관계를 사용하면 M*N개의 선택사항을 위해 M*N개의 하위 클래스르 정의해야 한다.

브리지 패턴을 적용하면 M개의 선루프 클래스, N개의 허브클래스만 설계하고 합성을 통해 서로 다른 스타일의 차량을 결합할 수 있다.
```java
public class Car {
    private SunProof sunProof;
    private Hub hub;

    public Car(SunProof sunProof, Hub hub) {
        this.sunProof = sunProof;
        this.hub = hub;
    }
}
```

## 7.5 퍼사드 패턴
인터페이스를 재사용하기위해 인터페이스를 세분화하고 단일책임을 갖도록 해야한다.
하지만 인터페이스를 너무 세분화하면 번거로워진다.


### 1. 퍼사드 패턴과 인터페이스 설계
시스템 A는 a, b, c, d라는 4개의 인터페이스를 제공하고 시스템 B는 시스템 A의 a, b,  인터페이스를 사용한다고 하자.
퍼새드패턴은 시스템 B에서 사용할 수 있도록 인터페이스 a, b, c를 하나로 묶어 인터페이스 x로 제공해준다.

-> 효율성등의 문제로 일괄 처리를 위해 사용.(플젝에서 여러개의 작은 정적 이미지를 한 이미지 파일로 묶어서 내려주는 것과 비슷)

### 2. 퍼사드 패턴의 응용: 인터페이스 사용성 개선하기
### 3. 퍼사드 패턴의 응용: 인터페이스 성능 향상하기
### 4. 퍼사드 패턴의 응용: 트랜잭션 문제 해결하기

## 7.6 복합체 패턴
복합체 패턴은 주로 트리 구조의 데이터를 처리하는데 사용된다.

### 1. 복합체 패턴 기반의 디렉터리 트리
복합체패턴 : 부분-전체 계층 구조로 인식하는 트리 구조로 구성된 객체 컬렉션
(계층적인 모델을 여러 클래스에 거쳐 설계한 것이라고 생각하면 될듯)

### 2. 복합체 패턴 기반의 휴먼 트리

## 7.7 플라이웨이트 패턴
플라이웨이트 패턴 : 공유를 위해 사용되는 패턴으로, 객체를 재사용하여 메모리를 절약하는 것이 목적이다.
공유되는 객체는 불변이어야만 한다.

### 5. 플라이웨이트 패턴과 싱글턴 패턴, 캐시, 오브젝트 풀의 차이
- 플라이웨이트 패턴과 싱글턴 패턴의 차이 : 플라이웨이트 패턴은 여러 객체를 생성할 수 있다.
다중 인스턴스 패턴과도 다른 것이, 플라이웨이트 패턴은 메모리를 절약하는 것이 목적인 반면 다중 인스턴스 패턴은 객체의 수를 제한하는 것이 목적이다.
- 플라이웨이트 패턴과 캐싱의 차이점 : 플라이웨이트 패턴은 팩터리 클래스를 사용하여 생성된 객체를 캐싱한다. 플라이웨이트 패턴에서의 캐시는 효율성 개선을 위한 것이 아니라 저장소로써 사용되기 때문에 다르다.
- 플라이웨이트 패턴과 오브젝트 풀의 차이점 : 풀링은 `반복사용`이 목적으로 매번 생성하지 않고 기존의 객체를 가져오는 것을 통해 시간을 절약하는 것이고, 플라이웨이트는 `공동사용`이 목적으로 시간이 아닌 공간을 절약하는 것이 목적이다. 