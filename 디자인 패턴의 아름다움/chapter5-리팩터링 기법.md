5장. 리팩터링 기법
리팩터링 할 때는 코드의 나쁜냄새와 설계 결함에 대한 통찰력을 기반으로 설계원칙, 디자인패턴, 코딩규칙 등을 합리적이고 능숙하게 사용해야함

# 1. 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법

### 1.1. 리팩터링의 목적

코드에 대한 이해를 쉽게 하기 위해 소프트웨어의 내부 구조를 개선하는 것.
외부 동작을 변경하지 않고 수정 비용을 줄이는 것이 목표

리팩터링이 필요한 이유

- 코드품질을보장하며 품질저하를 방지할 수 있다.
- 고품질 코드는 반복적인 작업에서 나온다
- 기술적 성장을 위해(설계원칙, 디자인패턴을 적용해볼 수 있는 기회)

### 1.2. 리팩터링의 대상

대규모 리팩터링 : 시스템모듈, 코드구조, 클래스 간 관계 등 최상위 코드 설계를 대상으로함

소규모 리팩터링 : 표준명명, 주석, 함수제거, 중복제거 등 클래스, 함수, 변수 수준에서 코드 세부 정보를 리팩터링하는 것

### 1.3. 리팩터링의 시기

코드가 망가진 후에는 늦는다.

### 1.4. 리팩터링의 방법

대규모 리팩터링 : 종합적인 꼐획을 수립하여 질서있고 단계적으로 진행

소규모 리팩터링 : 시간될때마다

깨진 유리창 효과가 발생하지 않도록 가끔 코드를 리팩터링해야함.

# 2. 단위 테스트

리팩터링이 잘못되지 않도록 하는 효과적인 수단.

### 2.1. 단위 테스트에 대해

단위테스트는 코드의 정확성을 테스트하기 위한 것

예상되거나 예상치 못한 상확에서 코드가 올바르게 실행될 수 있도록 가능한 상황을 포괄하는 테스트 케이스를 신중하게 생각하고 설계해야함.

설계먼저하고 그것을 코드로 변환하기

### 2.2 단위 테스트 코드를 작성하는 이유

- 버그를 찾는 데 도움이 된다
- 코드 설계에서 문제를 찾는데 도움이 된다.
  → 테스트 용이성등으로 판단
- 단위테스트 코드 작성 과정이 곧 코드 리팩터링에 해당
  → 코드를 한 번 더 검토할 수 있게됨
- 코드에 빠르게 익숙해지도록 도와줌
  → 단위테스트가 코드 문서와 주석의 역할을 대신할 수 있다.

### 2.3 단위 테스트를 설계하는 방법

단위테스트는 테스트케이스를 설계하고 그 테스트케이스를 코드로 변환하는 프로세스

- 단위테스트 코드를 작성할 때 구현 논리를 이해하는 것이 중요한가?
  → 코드를 한 줄씩 따라가면서 구현 논리 자체에 대한 단위 테스트를 설계하면 안된다. 코드의 구현논리가 변경되었을 때 외부 동작이 변경되지 않았음에도 테스트에 실패할 수 있다.

### 2.4 단위 테스트를 작성하기 어려운 이유

작업이 길어지고 많아질수록 단위테스트에 대한 요구사항이 낮아지며 깨진유리창효과가 발생하며 작성하지 않게 됨.

→ 코드가 수정될 때마다 점진적으로 단위테스트를 추가해 나가야 함.
→ 코드에 대한 주인의식이 있어야함
→ **단위테스트의 이점을 진정으로 느껴야함**

# 5.3 코드 테스트 용이성

### 3.1 테스트 가능한 코드를 작성하는 방법

외부서비스에 의존할때 발생하는 문제

- 모의데이터로 테스트가 불가능할 수 있다.
- 네트워크를 통해야 한다면 시간이 오래 걸리고 단위 테스트 수행에 영향을 줄 수 있다.

→ Mock을 통해 외부시스템, 데이터베이스, 네트워크, 파일시스템과 같이 제어할 수 없는 구성요소에 대한 족성 관계를 끊을 수 있다.

new키워드로 객체의 의존성을 생성하는 대신 의존성 주입을 통해 테스트 용이성을 향상시키자.

싱글턴 클래스는 전역변수와 동일하기 때문에 메서드를 상속하거나 재정의하는 방식으로 임의값을 넣을 수도 없고 의존석 주입으로 대체할 수도 없다.
→ 싱글턴이 아닌 패턴으로 리팩터링 하자

시간에 따라 코드의 흐름과 결과가 영향을 받는 코드 문제 해결방법

- 해당 부분이 있는 메서드를 재정의한다.
  → 해결은 가능하지만 클래스 객체 생성에 복잡한 논리가 포함되어 비합리적이다.
- 해당부분을 추상화하여 테스트용이성을 높인다.

단위테스트는 복잡한 기능에 대해서만 작성하면 되고 간단한 로직은 굳이 테스트할 필요없다.

테스트코드가 작성하기 쉬운지는 해당클래스의 응집도, 결합도에 달려있다.

응집도가 높고 결합도가 낮아야 테스트코드를 작성하기 쉬워진다.

### 3.2 테스트가 불가능한 코드

- 보류중인 동작(출력이 무작위이거나 불확실한 케이스)
- 전역변수
  한 테스트에서 전역변수 값을 조작하면 다음 테스트에서 테스트에 실패할 수 있따. 변수를 초기화하는 기능을 제공하여 해결할 수 있으나 멀티스레드 방식을 가정하면 문제는 잔존해있다.
- 복잡한 상속관계
  단위테스트를 위해 종속객체를 모의구현해야 하는 경우, 이 종속객체를 전부 모의구현해야하기에..

# 4. 디커플링

대규모 리팩터링의 주요 목적

### 4.1 디커플링이 중요한 이유

응집도가 높고 결합도가 낮은 코드를 만들 수 있다,.

코드의 복잡성을 효과적으로 제어할 수 있다.

### 4.2 코드를 디커플링해야 하는지 판단하기

코드 일부를 수정했을때 전체코드를 모두 건드려야 한다면 결합도가 높다는 것. → 디커플링 필요

모듈클래스 사이의 의존 관계가 복잡하고 혼란스럽다면 코드 구조에 문제가 있는것 → 디커플링으로 의존성 단순화 필요

### 4.3 코드 디커플링 방법

- 캡슐화와 추상화로 디커플링하기
- 중간 계층으로 디커플링하기
  → 중간계층이 과도기적 역할을 하여 개발 프로세스와 리팩터링을 동시에 진행할 수 있다.
  모듈 사이 똔느 클래스 사이의 의존성 단순화(카프카를 떠올리자)
- 모듈화와 계층화로 디커플링하기
- 고전적인 코드 설계 원칙 사상을 사용한 디커플링
    - 단일 책임 원칙
    - 구현이 아닌 인터페이스 기반의 프로그래밍
    - 의존성 주입
    - 상속 대신 합성 사용

# 5. 리팩터링 예제

### 5.7 예외 처리를 위한 리팩터링

예외 처리 방법

1. 오류 코드 반환
2. null 반환
   단점은, null처리를 까먹으면 NPE발생할 수 있고 null처리가 비즈니스 논리와 결합되어 코드의 가독성에 영향을 미침.
   이러한 단점이 있더라도 get, select~ 등 조회 함수에서는 null을 반환하는 것이 정상적이고 합리적인 결과임
3. 비어 있는 객체 반환
   null반환의 단점을 보완가능
4. 예외처리
   checked excepton, unchecked exception 두 케이스로 예외 유형을 정하여 처리 가능
    1. ArrayOutOfBoundException이나 데이터베이스 연결 실패같은 복구 불가능한 예외는 catch를 사용하더라도 복구할 수 없으므로 unchecked exception을 사용하는 것이 적절하다.

모든 예외를 실행시간예외(unchecked exception)으로 처리해야 한다는 주장에 대한 이유

- 컴파일 예외는 함수의 정의가 길어지므로 가독성을 저해하고 함수 사용성을 떨어뜨린다.
- 예외를 명시적으로 잡아야 하므로 코드 구현이 복잡해진다.
- 개방 폐쇄 원칙에 위배된다.
  → 함수 호출 체인에서 위에 위치한 모든 함수가 해당 예외가 catch되기 전까지 코드가 수정되어야 하기 때문

**예외처리방법**

1. catch하여 처리하고 상위코드에 전파하지 않기
2. 상위 함수에 예외를 그대로 전달하기
3. 발생한 예외를 감싸서 상위함수에 새로운 예외 전달하기

예외처리방법은 상위 함수가 해당 예외에 대해 관심을 가지고 있는지에 대해 달렸다.

- 상위함수가 예외에 관심이 있다면 상위함수에 예외를 전달(2, 3번 방법)하고,
- 상위함수가 예외에 관심이 없다면 직접 catch(1번 방법)하여 처리한다.

상위함수에예외를 전달하기로 결정했다면 해당 예외를 그대로 전달할지, 새 예외로 감사서 전달할 것인지는 상위 함수가 해당 예외를 이해할 수 있는지에 따라 달렸다.

- 상위함수가 이해할 수 있다면 상위함수에 직접 전달(2번 방법)하고
- 상위함수가 이해할 수 없다면 새 예외로 전달(3번 방법)한다.

**비정상적인 상황에서 null을 반환할까 예외를 발생시킬까?**

비정상적인 동작을 하는 경우에는 null을 반환하는 것보다 예외를 발생시키는 것이 합리적이다.

**매개변수로 전달된 값 확인은 어디서 하는게 맞는가?**

- 만함수가 클래스 내에서만 호출되고 완전히 통제하에 있는 private함수일 경우
  이 함수를 호출할 때 null또는 빈 문자열을 전달하지 않는지 확인하기만 하면 된다.
  → private함수에서는 null이나 빈 문자열에 대한 판단을 할 필요가 없다.
- 함수가 public함수이거나 protected 함수인 경우
  이 경우에는 호출자의 행동 제약을 할 수 없기 때문에 누군가 실수로 null이나 빈 문자열을 매개변수로 전달할 수 있다.
  → 강건한 코드를 위해 public이나 protected함수에서는 null이나 빈문자열을 처리하는 것이 필수적이다.