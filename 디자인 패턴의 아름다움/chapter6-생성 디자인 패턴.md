# Chapter 6. 생성 디자인 패턴
객채생성 문제를 해결하고 복잡한 생성 프로세스를 캡슐화하기 위한 디자인 패턴

## 6.1 싱글턴 패턴 (1)
### 1. 싱글턴 패턴의 정의
어떤 클래스의 객체 또는 인스턴스를 하나만 생성할 수 있게 하는 디자인 패턴

### 2. 싱글턴 패턴의 구현
**싱글턴 패턴의 조건**
- 생성자는 new예약어로의 인스턴스 생성을 피하기 위해 private 접근권한으로 설정한다
- 객체가 생성될 때 스레드안전을 보장해야한다
- 지연로딩 지원여부를 확인해야한다.
- getInstance()함수의 성능이 충분해야한다.

**싱글턴 패턴 구현**
- 즉시초기화 방식(eager) : 클래스가 메모리에 적재될 때 이미 생성되어 초기화가 완료되어있는 구현방식. 스레드 세이프하지만 인스턴스가 사용되는 시점에 생성되지 않고 항상 미리 생성된다
- 늦은초기화 방식(lazy) : 인스턴스 생성과 초기화가 실제 사용전까지 일어나지 않는다. 인스턴스 생성에 많은 리소스가 필요한 경우 이 방식이 적합하다.
다만 OOM같은 이슈를 미리 알 수 없다. fail-fast(문제가 있다면 빠르게 노출)설계원칙에 따라서는 즉시초기화 방식이 더 적합하다.
낮은 동시성문제로 인해 병목 현상이 발생할 수 있다.
- 이중잠금 : 지연적재와 높은 동시성을 모두 지원한다.
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static IdGenerator instance;

    private IdGenerator() {
    }

    public static IdGenerator getInstance() {
        if (instance == null) {
            synchronized (IdGenerator.class) { //클래스레벨의 잠금처리
                if (instance == null) {
                    instance = new IdGenerator();
                }
            }
        }
        return instance;
    }

}
```
늦은 초기화 방식의 구현에서는 메서드 레벨의 잠금처리로 인해 낮은 동시성 문제로 병목 현상이 발생할 수 있다.
- 홀더에 의한 초기화 : 정적 내부 클래스를 사용하는 방식
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);

    private IdGenerator() {
    }

    private static class SingletonHolder {
        private static final IdGenerator instance = new IdGenerator();
    }

    public static IdGenerator getInstance() {
        return SingletonHolder.instance;
    }
}
```
SingletonHolder는 정적 내부 클래스이므로 외부클래스인 IdGenerator클래스가 메모리에 로드되는 시점에 SingletonHolder클래스는 적재되지 않는다.
대신 getInstance()함수가 처음 호출될 때 적재되어 지연적재가 가능하다.
- 열거 : enum타입 특성을 이용한 싱글턴 구현. 스레드 안정성과 인스턴스의 유일성 보장

### 3. 싱글턴 패턴의 적용
객체를 생성하여 사용하다보면 동시성문제가 발생할 수 있다.
클래스래벨 잠금으로 한 번에 하나의 스레드만 함수를 실행하도록 하여 동시성 문제를 해결할 수 있다.

싱글턴 패턴 방식을 사용하여 동시성 문제를 쉽게 하결할 수 있다.

### 4. 싱글턴 패턴의 단점
- 클래스간의 의존성을 감춘다 : 생성할 때 명시적으로 생성하지 않아서 의존성이 잘 드러나지 않는다.
- 코드 확장성에 영향을 미친다
- 테스트 용이성에 영향을 준다 : 싱글턴 클래스가 멤버 변수를 보유하고 있다면 이는 전역변수와 동일한 효과를 가진다.
- 매개변수가 있는 생성자를 지원하지 않는다.(다양한 방법으로 해결가능하다.)

### 5. 싱글턴 패턴의 대안
유일한 클래스를 생성하는 방법으로 싱글턴 패턴 대신 정적 메서드를 사용하자


## 6.2 싱글턴 패턴 (2)
### 1. 싱글턴 패턴의 유일성
싱글턴 클래스에서 객체의 유일성이 보장되는 범위는 프로세스 내로 한정된다.
싱글턴 클래스는 여러 프로세스에 걸치면 결국 유일하지 않다.(당연히;)

### 2. 스레드 전용 싱글턴 패턴
싱글턴 패턴은 프로세스 범위 내에서 유일성이 보장된다.
더 작은 스레드 범위 내에서 유일성을 보장하게 하려면 어떻게 할가?
-> 각 스레드id를 저장하는 map을 만든다.

### 3. 클러스터 환경에서의 싱글턴 패턴
분산 싱글턴 패턴
클러스터에서 유일하다는 것은 여러 프로세스에서도 유일하다는 것이다.

분산 싱글턴 패턴을 구현하기 위해 싱글턴 클래스의 객체를 직렬화하고 파일과 같은 외부 공유 저장 영역에 저장할 수 있다.

### 4. 다중 인스턴스 패턴
싱글턴 : 1개
다중 인스턴스 : N개(N은 제한되어 있는 정수)

## 6.3 팩터리 패턴(1)
### 1. 단순 팩터리 패턴
팩터리 클래스 내에서 매개변수의 분기에 따라 적합한 구현체 인스턴스 반환하는 방식.
새 인스턴스 추가시 코드 수정을 줄이기 위해 map을 만들어서 구현체 인스턴스들을 미리 생성해둘 수 있다.

### 2. 팩터리 메서드 패턴
팩터리 클래스를 각 비즈니스 요구사항에 맞게 다형성을 사용한다.

```java
public interface Factory {
    Inst createInstance();
}

public class AFactory implements Factory {
    @Override
    public Inst createInstance() {
        return new AInst();
    }
}
...
```

그리고 map에 팩터리를 넣어두어서 비즈니스에 맞는 팩터리를 꺼내어 상요한다.

### 3. 추상 팩터리 패턴
팩터리가 여러 유형의 인스턴스를 만든다.
이 패턴을 통해 팩터리 클래스의 수를 줄일 수 잇다.

### 4. 팩터리 패턴의 적용 대상
- if분기에 판단 논리가 있으며 유형에 따라 다른 객체를 동적으로 생성하는 경우
- 단일 객체 자체의 생성 프로세스가 비교적 복잡한 경우

**팩터리 패턴의 역할**
- 생성과정을 캡슐화할 수 있다.
- 생성과정을 팩터리 클래스로 추출 후 재사용할 수 있다.
- 호출자가 생성방법을 알 필요가 없다
- 복잡한 코드를 간결하게 바꿀 수 있다.

## 6.4 팩터리 패턴 (2)
### 1. DI컨테이너와 팩터리 패턴의 차이
DI컨테이너는 전체 응용 프로그램에서 모든 클래스의 객체 생성을 담당한다.
DI컨테이너는 객체 생성 외에 설정분석, 객체 생명주기 관리 등 다른 작업도 한다.

### 2. DI컨테이너의 핵심기능
1. 설정분석
DI컨테이너와 애플리케이션 코드는 고도로 디커플링 되어야 한다.
DI컨테이너에는 생성할 객체를 미리 지정할 수 없으며 앞으로 어떤 객체가 생성될지도 알 수 없다.

따라서 생성해야하는 객체를 알려주는 도구가 필요하며 이것이 바로 `설정`이다.

2. 객체 생성
3. 객체 생명주기 관리
지연 적재, 객체 생명주기에서의 메서드 호출 등.

### 3. DI컨테이너의 설계와 구현
DI컨테이너의 구현 핵심은 설정파일을 분석하고 그 결과를 기반으로 리플렉션을 통해 객체를 생성하는 것.


## 6.5 빌더패턴

### 1. 생성자를 사용한 객체 생성
매개변수가 많을때 코드의 가독성과 편의성이 떨어진다.
또한 순서나 개수를 잘못 기입하면 버그가 생길 수 있다.

### 2. setter메서드를 사용한 멤버 변수 설정
### 3. 빌더 패턴을 이용한 매개변수 검증
**setter메서드 방식의 문제점**
1. 필수적으로 설정해야할 멤버변수가 많다면 검증이 어렵다
2. 설정해야할 멤버변수끼리 의존성이 있을 경우 ex) a와 b가 설정된다면 c도 설정되어야 한다던가..
3. 불변객체여야 할 경우
=> 빌더패턴을 사용하여 문제해결 가능하다

### 4. Guava에서 빌더패턴 적용
### 5. 빌더패턴과 팩터리 패턴의 차이
팩터리 패턴 : 유형은 다르지만 연관되어 있는 객체를 생성할 때 사용. 어떤 유형의 객체를 생성할지는 매개변수에 의해 결정됨
빌더패턴 : 복잡도가 높은 객체를 생성할때 사용. 

## 6.6 프로토타입 패턴
### 1 프로토타입 패턴의 정의
동일한 클래스 기반으로 생성된, 차이가 크지 않은 객체를 생성할 경우 생성 시간을 절약하기 위해 프로토타입을 사용하여 복사를 통해 새 객체 생성
프로토타입 패턴 : 프로토타입을 기반으로 객체를 생성하는 방식

### 2. 프로토타입 패턴의 적용
### 3. 프로토타입 패턴의 구현
1. 참조 객체를 재귀적으로 복사하는 방식
2. 객체 직렬화 후 새 객체로 역직렬화 하는 방식





## 내 결론
- 인스턴스 생성에선 빌더 패턴이 깔끔한듯. 특히 setter를 이용한 방식은 코드가 여기저기 퍼질 수 있어서 보기 어려운 것 같음.  


