# chapter3. 설계원칙
설계원칙 SOLID, KISS, YAGNI, DRY, LoD에 대한 설명

## 1. 단일 책임 원칙(Single responsibility principle, SRP)
클래스와 모듈은 하나의 책임 또는 기능만을 가지고 있어야 한다.

- 클래스에 단일 책임이 있는지를 평가하기 위한 명확한 기준은 없다.
- 개발할 때 너무 과도하게 세분화하여 설계할 필요는 없다.

## 2. 개방 폐쇄 원칙(open-closed principle, OCP)
확장할 때는 개방, 수정할 때는 폐쇄
모듈, 클래스, 함수와 같은 소프트웨어의 단위들은 확장을 위해 개방되어야 하지만 수정을 위해서는 폐쇄되어야 한다.
-> 기능을 추가할때는 수정보다는 기존 코드를 기반으로 모듈, 클래스, 함수등을 추가하는 방식이 되어야 한다.

- 코드를 수정한다고 해서 개방폐쇄원칙을 위반하는 것은 아니다. 메서드를 추가하기 위해 수정을 하는 것을 수정이라고 하지 않는다. 이는 확장이다.
- 개방 폐쇄 원칙 기반의 높은 확장성을 지원하는 코드를 작성하는 방법의 핵심은 확장 포인트를 미리 준비해두는 것이다.
- 개방 폐쇄 원칙을 위해 코드의 가독성을 희생할 필요가 있다.

## 3. 리스코프 치환 원칙(Liskov substitution principle, LSP)
하위 유형 또는 파생 클래스의 객체는 프로그램 내에서 사우이 클래스가 나타나는 모든 상황에서 대체 가능하며, 프로그램이 원래 가지는 논리적인 동작이 변경되지 않으며 정확성도 유지된다.

- 다형성은 코드를 구현하는 방식에 해당하지만 리스코프 치환 원칙은 상속 관계에서 하위 클래스의 설계 방식을 설명하는 설계 원칙에 해당한다.. 즉 상위 클래스를 대체할 때 프로그램의 원래 논리적 동작이 변경되지 않고 프로그램의 정확성이 손상되지 않도록 해야 한다.
-> 상위메서드의 논리적 흐름과 규칙을 위배하지 않으면서 다형성을 구현하는 것
  
## 4. 인터페이스 분리 원칙(Interface segregation principle, ISP)
코드의 클라이언트는 필요하지 않은 인터페이스를 사용하도록 강요되어ㅗ서는 안된다.

인터페이스나 클래스 라이브러리 기능을 설계할 때 인터페이스 또는 기능의 일부가 호출자 중 일부에만 사용되거나 전혀 사용되지 않는다면 불필요한 항목을 강요하는 대신, 인터페이스나 기능에서 해당 부분을 분리하여 해당 호출자에게 별도로 제공해야 하며, 사용하지 않는 인터페이스나 기능에는 접근하지 못하게 해야 한다.

API나 가능은 가능한 한 단순해야 하며 하나의 기능에 여러 다른 기능 논리를 구현하지 않아야 한다.

- 서로 관련없는 기능을 몰아넣도록 인터페이스를 설계할 경우 새 인터페이스가 추가될 때마다 해당 기능들을 모두 구현해야 한다. -> 좋지않은 설계

## 5. 의존 역전 원칙(dependency inversion principle, DIP)
제어 역전 : 전체 프로그램 흐름의 실행을 제어하는 코드의 흐름이 프로그래머에서 프레임워크에 의해 제어되도록 역전되는 것
의존성 주입 : 클래스 내부에 종속되는 클래스 객체를 생성하는 대신 외부에서 종속 클래스객체를 주입해주는 것
의존성 주입 프레임워크 : 모든 클래스 객체와 클래스 간의 의존성을 구성하기 위해 자동으로 객체를 생성하고 주입해 주는 프레임워크(= 제어반전 컨테이너) 

의존 역전 원칙 : 상위모듈은 하위 모듈에 의존하지 않아야 하며 추상화에만 의존해야 한다.

## 6. KISS원칙과 YAGNI원칙
KISS원칙 : Keep It Simple and Stupid, 가능한 한 단순하게 유지하라.
- 코드 라인이 적다고 해서 꼭 단순한 것은 아니다.
- 복잡한 코드가 반드시 KISS원칙을 위반하는 것은 아니다.(ex KMP알고리즘, 복잡한 문제를 해결하기 위한 복잡한 알고리즘)

### KISS원칙을 만족하기 위한 코드 작성법
- 복잡한 기술을 사용하여 코드를 구현하지 않는다
- 기존 라이브러리를 사용하는 것을 고려한다.
- 과도하게 최적화하지 않는다. (비트연산, 복잡한 조건문 등을 지양)

YAGNI원칙 : you ain't gonna need it, 현재 사용되지 않는 기능을 설계하지 말고 현재 사용되지 않는 코드를 작성하지 않는다.

## 7. DRY 원칙
don't repeat yourself, 중복 코드를 작성하지 말라.
하지만 동일한 중복코드라 하더라도 반드시 DRY원칙에 위배되는 것은 아니다.

- 기능적 중복을 어떻게 피할것인가? 예를 들어서 utils 클래스에 코드를 만들다보면 같은 기능을 하는 중복코드가 생겨나는 경우가 있었는데 이런 경우를 어떻게 방지할 수 있을까? 

## 8. LoD(데메테르의 법칙, law of Demeter, LoD, ==최소 지식의 원칙)
높은 응집도와 낮은 결합도를 달성하는데 도움을 준다.
높은 응집도 : 유사한 기능은 동일한 클래스에 배치되어야 함.
낮은 결합도 : 클래스 간의 의존성이 단순하고 명확해야함.(한쪽을 수정하도 다른 한쪽은 거의 수정되지 않도록)

최소지식의 원칙 : 모든 유닛이 자신과 매우 밀접하게 관련된 유닛에 대해서 제한된 지식만 알아야 한다.
또는 모든 유닛은 자신의 친구들에게만 이야기해야 하며, 알지 못하는 유닛과는 이야기하면 안된다.
-> 직접 의존성이 없어야 하는 클래스 사이에는 반드시 의존성이 없어야 한다.
-> 의존성이 있는 클래스는 필요한 인터페이승네만 의존해야한다.

## 생각하기
- dry원칙에서 기능적 중복을 어떻게 피할것인가? 예를 들어서 utils 클래스에 코드를 만들다보면 같은 기능을 하는 중복코드가 생겨나는 경우가 있었는데 이런 경우를 어떻게 방지할 수 있을까?
- lod원칙을 보고 모든 레이어에서 의존하고 있는 클래스가 생각났다(ex, param클래스). 어디까지 분리하는게 맞는걸까? 각 레이어별로 각각 분리하는게 맞나? 과하지는 않나?  
