# 2. 애자일 설계

애자일(agile) - 기민함, 날렵함

애자일하게 소프트웨어를 만들어나가면 설계는 언제하나? 좋은 설계가 필요하지 않은가? 란 의문이 들 수 있음.

애자일은 미래의 구현과 구조보단 현재의 시스템에 초좀을 맞춘다.

#### 잘못된 설계의 증상

설계가 잘못되었을때 나타나는 증상

- 경직성 : 설계를 변경하기 어려움
- 취약성 : 설계가 망가지기 쉬움
- 부동성 : 설계를 재사용하기 어려움
- 점착성 : 제대로 동작하기 어려움
- 불필요한 복잡성 : 과도한 설계
- 불필요한 반복 : 마우스 남용
- 불투명성 : 혼란스러운 표현

이런 '코드의 악취'같은 문제를 피하기 위한 방법을 알아본다

#### 원칙
'코드의 악취'를 제거하고 현재 기능 집합에 대해 최적의 설계를 구성할 수 있도록 돕는 원칙도 알아본다

1. SRP : 단일 책임 원칙
2. OCP : 개방 폐쇄 원칙
3. LSP : 리스코프 치환 원칙
4. DIP : 의존 관계 역전 원칙
5. ISP : 인터페이스 분리 원칙

#### 악취와 원칙
보통 코드악취는 위와 같은 원칙을 위반했을때 발생한다.

하지만 원칙을 항상 따르는 것은 불필요한 복잡성을 높일 수 있다.

(꼭 필요할때만 적용하는 것이 베스트)


## Chapter 7. 애자일 설계란 무엇인가?
소프트웨어 설계에 대한 내용

### 소프트웨어에서 어떤 것이 잘못되는가?
소프트웨어는 시간이 지날수록 점점 망가지고 유지보수가 어려워진다.

이는 재설계의 필요로 이어지는데, 재설계는 성공하기 어렵다.(재설계를 하는 와중에도 시스템은 계속 발전하고 변경되기 때문에)

새로운 설계는 발전되고 변경될 도착점을 쫓아가야한다. 그래서 어렵다.

### 설계의 악취 : 부패하고있는 소프트웨어의 냄새
다음과 같은 냄새가 소프트웨어는 망가지고 있다는 지표이다.

1. 경직성 : 설계를 변경하기 어려움. 변경하려면 시스템의 다른 부분들까지 많이 변경해야함
2. 취약성 : 설계가 망가지기 쉬움. 변경하면 관련없는 부분이 망가짐
3. 부동성 : 설계를 재사용하기 어려움. 
4. 점착성 : 제대로 동작하기 어려움. 옳은 동작을 하는 것이 어려움 
5. 불필요한 복잡성 : 과도한 설계. 직접적인 효용이 전혀 없는 설계로 인한.. 
6. 불필요한 반복 : 마우스 남용. 단일 추상개념으로 통합할 수 있는 반복적인 구조가 설계에 포함됨. 
7. 불투명성 : 혼란스러운 표현. 잃고 이해하기 어려움

#### 1. 경직성
단순한 방법으로도 소프트웨어를 변경하기 어려운 경향. (한 군데를 수정하면 의존적인 모듈에서 단계적으로 수정이 발생하는..)

간단한 수정처럼 보여도 예상하지 못한 간접적인 영향때문에 작업시간 추정이 어렵다.

#### 2. 취약성
한 군데를 변경했을때 프로그램의 많은 부분이 잘못되는 경향.

#### 3. 부동성
다른 시스템에서 유용하게 쓸 수 있는 부분을 포함하고 있으나 그런 부분을 원래 시스템에서 분리하는 수고와 위험성이 큰 케이스.

#### 4. 점착성
`소프트웨어의 점착성`과 `환경의 점착성` 두 형태로 나눌 수 있다.

- 소프트웨어의 점착성

변경사항을 마주했을때 설계를 유지하며 변경하는 케이스가 있고, 설계를 수정하여 변경하는 케이스가 있다.

만약, 변경할 때 설계를 유지하는 방법이 더 어렵다면 설계의 점착성은 높아진다.

설계를 수정하여 변경하는 케이스는 잘못된 동작을 하게될 가능성이 높고, 올은 동작을 하기 힘들어진다.

이 때문에 프로그래머는 설계를 유지할 수 있는, 변경이 쉬운 설계가 필요한데 그렇지 않다면 점착성이 높은 것이다.

- 환경의 점착성

개발환경이 느리고 비효율적일때 발생한다.

컴파일 시간이 길거나, git에서 pull 받고 checkout하는 등의 동작이 느리거나..


점착성을 최소화하기 위해 설계를 유지하기 쉬운 시스템과 효율적인 프로젝트 환경이 필요하다.

#### 5. 불필요한 복잡성
현 시점에서 유용하지 않은 요소가 설계에 포함되어 있는 경우를 말한다.

개발자가 필요할 것으로 예상되는 기능이나 설계를 집어넣을때 발생하는데,

이게 미래의 변경에 대해 유연해질 것처럼 보여서 괜찮아보이지만 그렇지 않다.
 
사용되지 않는 구성요소들이 늘어나서 소프트웨어가 복잡하고 이해하기 어려워질 뿐이다.

#### 6. 불필요한 반복
시스템에서 반복되는 부분은 흔하게 발생한다.

어떤 작업자가 작성한 코드에서 필요한 부분을 추가해 다른 코드에 붙이는.. 등의 작업이 반복되면 조금씩 다른 형태로 반복되어 나타나게 되는데

이로인해 추상화된 개념을 잃게된다.

반복되는 부분을 찾아 적절한 추상화를 통해 이를 얿ㅅ애는 일은 시스템을 이해하고 유지보수하기 쉽게 만든다.

하지만 반복되는 부분을 찾아서 시스템을 변경하는 것은 모든 반복되는 부분에서 조금씩 다른 부분이 있기 때문에 되다.

#### 7. 불투명성
모듈을 이해하기 어려운 경향을 말한다.

발전하는 코드에 따라 시간이 지날수록 코드가 불명료해지는 경향이 있는데, 불투명성을 최소로 유지하기 위해 지속적인 노력이 필요하다.

불투명성의 최소화를 위해 읽는 사람의 입장에서 생각하고, 코드를 리팩토링하는데에 노력을 기울여야한다.

그리고 타인이 자신의 코드를 검토하도록 할 필요학 있다.

### 무엇이 소프트웨어의 부패를 촉진하는가?
애자일이 아닌 환경에선, 초기 설계에 없었던 요구사항 변경때문에 설계가 퇴화하게 된다.

요구사항의 변경은 보통 빠르게 이루어져야 해서 기존 설계에 익숙하지 않은 개발자가 작업을 맡게되는 까닭에,

기존 설계를 위반하는 변경이 축적되어 코드악취를 풍기게 된다.

하지만, 요구사항은 변경되는게 일반적이고 계속되는 요구사항 변경때문에 설계가 실패한다면 설계와 방식에 문제가 있는 것이다.

### 애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다.
애자일팀은 시스템의 설계를 가능한 단순하게 유지한다.

그리고 이를 단위테스트와 인수테스트로 뒷받침한다.

이런 작업을 통해 설계를 유연하고 변경하기 쉽게 유지하여 변경되는 요규사항에 맞춰 그 시점에 가장 적합한 설계를 가진 시스템을 만들어낸다.

### 'Copy'프로그램
프로그램을 작성하면서 요구사항이 변경되고, 추가됨에 따라 코드냄새가 발생. 이에 따라 설계를 개선하는.. 예시. 패스

p.115~

### 가능한 한 좋은 상태로 설계 유지하기
애자일에서 개발가는 설계를 가능한 적절하고 명료한 상태로 유지하기 위해 애쓴다.

코드에 부패가 발생하도록 놔두지 않는다.

어느 한 군데에서 발생하는 코드 냄새를 방치하면 나중엔 걷잡을 수 없이 퍼져나간다.

### 결론
애자일 설계는 과정이다.

원칙, 패턴, 소프트웨어의 구조, 가독성을 향상하기 위한 방식의 연속적인 적용이며,

설계를 간단하고 명료하고 표현적으로 유지하려는 노력이다.


## Chapter 8. 단일 책임 원칙(SRP)
단일 책임 원칙 ≈ 응집도

모듈이나 클래스의 변경을 야기하는 응집력에 대한 내용

### 단일 책임 원칙(SRP)
`한 클래스는 단 한가지의 변경 이유만을 가져야 한다.`

책임의 분리가 중요한 이유는 각 책임이 변경의 축 이기 때문이다.

한 클래스가 하나 이상의 책임을 맡는다면, 
- 그 클래스를 변경할 하나 이상의 이유가 있게된다.
- 그 책임들은 결합되고 다른 책임을 충족시키는 클래스의 능력을 저하시킨다. 


<img src="https://github.com/user-attachments/assets/825665fc-77e6-4c14-9ddd-c109b2cc0873" width="600">

위는 Rectangle이 도형의 계산과, gui에 그림을 그리는 두 가지 역할을 하고 있다.

이런 SRP위반은 다음의 문제들을 유발한다.
- geometry 애플리케이션에 불필요한 GUI기능을 포함해야한다. 결국 GUI를 위한 파일도 같이 배포되어야 하며 컴파일시간과 메모리 영역을 소비하게된다.
- Graphic 애플리케이션에서의 변경이 Rectangle의 변경을 유발한다면 geometry 애플리케이션도 재빌드, 재배포 해야할수도 있다. 그렇지 않으면 애플리케이션이 오동작 할수도 있다. 

<img src="https://github.com/user-attachments/assets/bade859c-b7c3-43cb-b560-592a465f9ee8" width="600">

좀 더 나은 설계는 책임을 서로 다른 클래스로 분리해넣는 것이다.

분리한 이후에는 gui가 어떻게 그려지든 geometic 애플리케이션에 영향을 주지 않는다.

### 책임이란 무엇인가?
책임 = 변경을 위한 이유

클래스를 변경하기 위한 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고 있는 것이다.

예를 들어보면..

- ex) SRP를 위반한 interface 예
```java
interface Modem {
	public void dial(Stringno);
	public void hangup();
	public void send(char c);
	public char recv();
}
```

위 케이스는 연결관리(dial, hangup), 데이터통신(send, recv)라는 두 개의 책임이 있다.

하지만, 두 책임을 항상 나눠야 하는것은 아니다.

두 책임이 분리되어야 하는지는 애플리케이션이 어떻게 바뀌느냐에 달려있는데

만약 애플리케이션이 연결 함수(dial, hangup)의 시그니처에 영향을 주는 방식으로 바뀐다면, 이를 호출하는 클래스는 자주 재컴파일되고 재배포 되어야 할것이므로, 이 설계는 `경직성`의 악취를 풍기게 된다.

이런 경우라면 아래와 같이 두 책임을 서로 나눠야한다
```java
interface DataChannel {
	public void send(char c);
	public char recv();
}

interface Connection {
	public void dial(Stringno);
	public void hangup();
}
```

반면에, 애플리케이션이 서로 다른 시점에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면 굳이 분리할 필요는 없다.

이런 경우 분리하면 오히려 `불필요한 복잡성`만 생기게 된다.

결론은, `변경의 축은 변경이 실제로 일어날 때만 변경의 축이다.`

아무 증상도 없는데 SRP나 다른 원칙을 적용하는 것은 좋지 않다.

### 결합된 책임 분리하기
위 DataChannel, Connection 두 인터페이스를 모두 결합한 클래스가 존재할 수 있다. 

이런 클래스가 바람직해보이지 않을 수 있는데, 모든 의존성이 필요악일 수 있다.

하드웨어나 OS의 세부적인 사항과 관련된 이유로 인해 책임이 결합되도록 만드는 경우가 종종 있다.

그리고 결국 의존하는것은 이 클래스가 아닌 위 두 인터페이스이기 때문에 이 클래스는 존재한다는 사실을 알 필요가 없으며 애플리케이션의 나머지 부분을 오염시키지도 않는다.

### 영속성

<img src="https://github.com/user-attachments/assets/51be01e6-3856-467f-8d9d-95fd935df070" width="600">

위 그림은 SRP를 위반한 사례인데,

Employee클래스는 비즈니스적인 규칙과 영속성제어를 포함한다.

이 두 책임은 서로 어울리지 않고 비즈니스적인 규칙과 영속성이 바뀌는 이유도 서로 다르다.

이렇게 경직성(설계를 변경하기 어려움), 취약성(설계가 망가지기 쉬움)이 강해진 경우 퍼사드나 프록시 패턴을 사용해서 두 책임이 분리되도록 리팩토링 해야한다.

### 결론
책임을 결합하는 것은 시스템을 만들면서 자연스럽게 발생한다. 이런 책임을 분리하는 것이 중요하다.

## Chapter 9. 개방 폐쇄 원칙(OCP)
### 개발 폐쇄 원칙
`소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.`

프로그램 한 군데를 변경했을때 의존적인 모듈에서 단계적인 변경을 불러일으키면 이 설계는 `경직성`의 악취를 풍긴다.

OCP는 나중에 일어날 변경이 더이상 수정을 유발하지 않게 충고해주며, OCP가 잘 적용되었다면 원래 코드의 수정이 아닌 새로운 코드를 덧붙이는 방식의 변경이 용이해진다.

### 상세 설명
OCP를 따르는 모듈은 다음 속성을 같는다.
1. 확장에 대해 열려 있다.

모듈의 행위가 확장될 수 있음을 의미한다. 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 행위를 추가해서 모듈을 확장할 수 있음을 의미한다.

2. 수정에 대해 닫혀 있다.

모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

### 해결책은 추상화다
추상화를 통해 고정되기는 해도 제한되지 않는 가능한 행위의 묶음을 표현할 수 있다.

OCP를 따르는 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀있을 수 있고,

그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

예를 보면..

ex) OCP를 따르지 않는 셜계
<img src="https://github.com/user-attachments/assets/378c987a-fba6-42a2-a486-aa43760c5030" width="600">

위 그림은 Client클래스가 Server클래스를 사용하는 예이다.

만약 Client가 다른 Server객체를 사용하게 하려면 Client클래스에서 새로운 Server클래스를 지정하도록 변경이 필요하다.


ex) OCP를 따르는 설계
<img src="https://github.com/user-attachments/assets/216b3c09-d12a-4a9a-91dc-4ddb4c66cffd" width="600">

위 그림에서 Client는 ClientInterface라는 추상화에 의존한다.

Server클래스는 ClientInterface의 파생 클래스이다.

만약 Client가 다른 Server클래스를 사용하려면 Client클래스의 변경 없이 ClientIntegerface클래스의 새 파생 클래스를 생성하면 된다.


**네이밍**
왜 위 그림에서 interface 이름에 Server가 아닌 Client가 들어갈까?

추상클래스는 자신을 구현하는 클래스보다도 클라이언트에 더 밀접하게 관련되어 있기 때문이다. 

### Shape 애플리케이션
OCP를 설명하기 위한 예제

원, 사각형을 그릴 수 있는 애플리케이션이 있다.

프로그램은 원과 사각형의 목록을 순서대로 따라가며 각각 그려야 한다.

### OCP 위반
ex) OCP를 위반한 예
```cpp
-- shape.h --

enum ShapeType {circle, square}

struct Shape{
    ShapeType itsType;
}

-- circle.h --

struct Circle {
    ShapeType itsType;
    double itsRadius;
    Point itsCenter;
}

void DrawCircle(struct Circle*);

-- square.h --

struct Square{
    ShapeType itsType;
    double itsSide;
    Point itsTopLeft;
}

void DrawSquare(struct Square*)

-- drawAllShapes.cc --

typedef struct Shape *ShapePointer;

void DrawAllShapes(ShapePointer list[], int n){
    int i;
    for(i=0;i<n;i++){
        struct Shape* s = list[i];
        switch(s->itsType){
            case square:
                DrawSquare((struct Square*) s);
                break
            case circle:
                DrawCircle((struct Circle*) s);
                break
        }
    }
}
```

위 예제에서 DrawAllShapes 함수는 새로운 도형 종류에 대해 닫혀 있을 수 없기 때문에 OCP를 따르지 않는다.(switch문에 새로운 도형의 분기가 필요함)

또한 도형을 추가하기 위해 ShapeType enum에 새 멤버가 필요하고 이 enum변수의 선언에 모든 도형이 의존하기 때문에 이 모두를 다시 컴파일 해야하고 Shpe에 의존하는 모든 모듈도 마찬가지이다.

### OCP 따르기
```cpp
class Shape{
    public : virtual void Draw() const = 0;
}

class Square : public Shape {
    public : virtual void Draw() const
}

class Circle : public Shape {
    public : virtual void Draw() const
}

void DrawAllShapes(vector<Shape*> & list) {
    vector<Shape*> :: iterator i;
    for(i = list.begin();i != list.end(); i++){
        (*i) -> Draw();
    }
}
```

위 예제에서는 DrawAllShapes 함수의 행위를 확장해서 새로운 도형을 그리고 싶다면 Shape 클래스의 새로운 파생클래스만 만들면 된다.

DrawAllShapes함수를 변경할 필요가 없어서 이는 OCP를 따른다. (수정 없이 확장 가능)

또한 새 도형 클래스를 추가한다고 해도 어떤 모듈에도 영향을 주지 않는다.

설계의 잘못된 증상 측면에서 보면..
- 경직성 : Shape의 새 파생클래스의 인스턴스를 실제로 생성하는 모듈을 제외하면 수정되어야 하는 모듈이 없고, 외에는 Shape에 의존하기 때문에 새 파생클래스를 몰라도 된다.
- 취약성 : 새로운 도형을 추가하는 것이 다른 애플리케이션 코드 변경 없이 새 파생클래스를 만들고 그 함수를 구현하는 것뿐이기 때문에 취약하지 않다 
- 부동성 : DrawAllShapes는 Shape 파생클래스의 편승 없이 다른 애플리케이션에서도 재활용될 수 있다. 따라서 부동성이 없다.

### 예상과 '자연스러운' 구조
예를 들어서 DrawAllShapes에서 도형을 그릴때 `원이 항상 사각형보다 먼저 그려져야한다`는 조건이 있으면 변경에 닫혀 있지 않게 된다.

이렇게 순서가 도형의 종류보다 더 중요한 시스템이서는 위와 같은 모델이 자연스럽지 않다.

모든 상황에서 자연스러운 모델은 없다.

또한 OCP를 따르는 것은 비용이 많이 든다. (적절한 추상화 만들기, 소프트웨어 설계의 복잡성 증가..)

따라서 경험과 상식을 통해 변경이 일어날 때까지 기다린 후 그에 따라 적절한 조치를 취하는것이 바람직하다.

### '올가미'놓기
발생가능한 변경에 '올가미'를 놓는 것(미리 준비하는..)은 소프트웨어를 유연하게 만들어줄 것이라 생각된다.

하지만 실제론 그렇지 않고 유지보사되어야 하는 `불필요한 복잡성`만 발생시킨다.

처음에는 변경이 되지 않을것이라 생각하고 작성하고, 변경이 일어나면 그 때 비슷한 변경으로부터 유연한 추상화를 구현하는 것이 좋다.

**변경 촉진하기**
이런 변경은 짧은 텀에 빈번하게 일어날 수록 적절한 추상화를 만드는 것이 쉬워진다.

이런 변경을 촉진하기 위한 방법으로는..
- 테스트를 먼저 작성한다. 테스트를 먼저 작성함으로써 시스템을 테스트 가능하게 만드는 추상화를 만들게 된다.
- 아주 짧은 주기로 개발한다
- 기반구조보다 기능 요소를 먼저 개발하고, 이 기능요소를 이해당사자에게 자주 보여준다.
- 가장 중요한 기능 요소를 먼저 개발한다.
- 소프트웨어를 빨리, 자주 릴리즈하고 사용자가 확인할 수 있게 한다.

### 명시적인 폐쇄를 위해 추상화 사용하기
아까 나왔던 순서의 변경에 대해 DrawAllShapes함수를 닫는 방법은?

폐쇄는 추상화에 기반을 둔다. 따라서 `순서 추상화`가 필요하다.

2개의 객체가 주어졌을때 어느 것을 먼저 그려야 하는지를 Precedes라는 메서드 하나를 추가했다.

ex) Precedes라는 순서 추상화 메서드가 추가된 예
```cpp
class Shape{
    public : virtual void Draw() const = 0;
    virtual bool Precedes(const Shape&) const = 0;
    bool operator<(const Shape& s) {
        return Precedes(s)
    }
}

template <typename P> class Lessp{
// 포인터의 컨테이너를 정렬하기 위한 유틸리티
    public : bool operator() (const P p, const P q) {
        return (*p) < (*q);
    }
}

void DrawAllShapes(vector<Shape*>& list) {
    vector<Shape*> orderedList = list;
    sort(orderedList.begin(), orderedList.end(), Lessp<Shape*>());
    vector<Shape*> :: const_iterator i;
    for(i = orderedList.begin();i != orderedList.end(); i++){
        (*i) -> Draw();
    }
}

```
ex) Circle::Precedes 메서드 구현 예
```cpp
bool Circle :: Precedes(const Shape& s) const {
    if(dynamic_cas<Suqre*>(s))
        return true
    else
        return false
}
```

하지만 순서를 지정하기 위해 Shape의 다른 파생클레스는 Precedes메서드를 Override해야하므로 OCP를 따르지 않는다.

즉, Shape의 새로운 파생 클래스에 대해 닫을 수 있는 방법이 없다.

Shape에 새로운 파생 클래스가 생성될 때마다, 모든 Precedes메서드는 변경되어야 한다.

### 폐쇄를 위해 '데이터 주도적'접근 방식 사용하기
만약 Shape의 파생클래스가 서로에 대해 아는 것을 막는다면 테이블 주도적 접근 방식(table-driven approach)을 사용할 수 있다.

ex) 
```cpp
# include <typeinfo>
# include <string>
# include <iostream>

using namespace std;

class Shape{
    public : virtual void Draw() const = 0;
    bool Precedes(const Shape&) const = 0;
    bool operator<(const Shape& s) {
        return Precedes(s)
    }
    private : static const char* typeOrderTable[];
}

const char* Shape :: typeOrderTable[] = {typeid(Circle).name(), typeid(Square).name(), 0}
// 이 함수는 테이블에서 클래스 이름을 찾는다.
// 테이블은 그려질 도형의 순서를 정의한다.
// 발견되지 않은 도형은 언제나 발견된 도형에 우선한다.

bool Shape :: Precedes(const Shape& s) const {
    const char* thisType = typeid(*this).name()
    const char* argType = typeid(s).name();
    bool done = false;
    int thisOrd = -1;
    int argOrd = -1;
    
    for(int i=0;!done;i++){
        const char* tableEntry = typeOrderTable[i];
        if(tableEntry != 0) {
            if(strcmp(tableEntry, thisType) == 0) {
                thisOrd = i;
            }
            if(strcmp(tableEntry, argType) == 0) {
                argOrd = i;
            }
            if (argOrd >= 0 && thisOrd >= 0) {
                done = true;
            }
        }else
            done = true;
        }
    }
    return thisOrd < argOld;
}
```

위 접근방식으로 DrawAllShapes를 일반적인 순서문제에 대해 닫을 수 있다.

그리고 Shape의 파생 클래스 각각을 새 Shape 파생클래스 추가에 따라 정렬하는 정책의 변화에 대해서도 닫을 수 있다.

(물론 Shape의 순서에 대해서 typeOrderTable은 닫혀있지 않다.)

### 결론
추상화를 통해 유연성, 재사용성, 유지보수성을 얻을 수 있으나, 모든 부분에 마구 추상화를 적용하는 것도 좋지는 않다.

자주 변경되는 부분에만 추상화를 적용하기 위한 노력이 필요하다.


## Chapter 10. 리스코프 치환 원칙(LSP)
### 리스코프 치환 원칙(LSP)
`서브타입은 기반타입으로 치환 가능해야 한다.`

어떤 기반클래스 A를 인자로 받는 함수 f(x)가 있다고 해보자.

만약 A의 파생클래스인 B가 f(x)의 인자로 넘겨졌을 때 f(x)가 잘못된 동작을 한다면, B는 LSP를 위반한다.

f(x)에서 B에 대해 올바른 동작을 하도록 조치를 취하게 되면 f(x)가 A의 파생클라스에 대해 닫혀있지 않은 것이며 OCP를 위반하게 된다.

결론적으로, LSP를 위반하면 기반클래스를 참조하는 코드의 변경에 취약해지며 OCP를 위반하게 되고 코드스멜을 만들게 된다.

### LSP 위반의 간단한 예
LSP위반은 OCP를 위반하는 런타임 타입 정보 사용으로 이어질 수 있다.

ex) OCP위반을 유발하는 LSP 위반
```cpp
struct Point {
  double x, y; 
}; 

struct Shape {
  enum ShapeType {
    square, circle
  } itsType;
  Shape(ShapeType t) : itsType(t) {
  }
}; 

struct Circle : public Shape {
  Circle(): Shape(circle) {
  }

  void Draw() const
  Point itsCenter; 
  double itsRadius; 
}; 

struct Square : public Shape {
  Square() : Shape(square) {
  }
  void Draw() const
  Point itsTopLeft; 
  double itsSide; 
}; 

void DrawShape(const Shape& s) {
  if (s.itsType == Shape :: square) 
    static_cast<const Square&>(s).Draw(); 
  else if (s.itsType == Shape :: circle) 
    static_cast<const Circle&>(s).Draw(); 
}
```
위 코드는 OCP, LSP를 모두 위반한다.

#### OCP 위반
DrawShape 함수는 OCP를 위반한다.

이 함수는 Shape클래스의 모든 파생클래스를 알아야하고 새 파생클래스가 생길때마다 변경이 필요하다.

#### LSP 위반
Shape의 파생클래스인 Circle, Squere는 LSP를 위반한다.

이 두 파생클래스는 Shape의 파생클래스임에도 Shape가 가진 함수를 오버라이드 하지 않기 때문에 Shape를 대체할 수 없다.

따라서 LSP 위반이며,

위 예시코드는 이 때문에 Shape의 파생클래스 타입을 검사한 후 적절한 Draw함수를 호출하는 코드가 필요해졌기 때문에,

LSP위반으로 인해 DrawShape 함수의 OCP위반이 유발되었다


### 정사각형과 직사각형, 좀 더 미묘한 위반
Rectable(직사각형) 클래스를 사용하는 예시
```cpp
class Rectangle {
  public : 
      void SetWidth(double w) {
        itsWidth = w; 
      }
      void SetHeight(double h) {
        itsHeight = h; 
      }
      double GetHeight() const {
        return itsHeight; 
      }
      double GetWidth() const {
        return itsWidth; 
      }
  private :
      Point itsTopLeft; 
      double itsWidth; 
      double itsHeight; 
};
```

위 코드는 직사각형 클래스를 나타낸다.

만약 정사각형(square)에 대해서도 조작할 수 있게 해달라는 요구사항이 있다고 해보자.

모든 정사각형은 직사각형이므로 IS-A 관계에 있으며 Square클래스는 Rectangle 클래스에서 파생된다고 보는것이 합리적이다.

하지만, 이런 생각이 문제를 발생시킬 수 있는데, 

첫번째로 Square는 itsHeight와 itsWidth멤버변수를 필요로 하지 않는다는 것이다.  
Square가 Rectangle을 상속하게 되면 이 멤버 변수들을 상속받는데 이는 메모리의 낭비이다.

두번째는 setWidth, setHeight가 Square에서는 부적절하다는 것이다. (가로, 세로 길이가 같기때문에)  
이 문제는 다음과 같이 오버라이드 하여 해결할 수 있다.
```cpp
void Square :: SetWidth(double w) {
    Rectangle :: SetWidth(w); 
    Rectangle :: SetHeight(w); 
}

void Square :: SetHeight(double h) {
    Rectangle :: SetHeight(h); 
    Rectangle :: SetWidth(h); 
}
```

(하지만 위 코드는 virtual로 선언하지 않아서 다형적이지 않고, Rectangle을 받는 인자에 Square 파생클래스를 넘겼을 때 문제가 발생할 수 있다., cpp)

최종적으로 아래의 코드로 Rectangle의 파생클래스 Square를 얻어낼 수 있다.

```cpp
class Square : public Rectangle {
    public :
        virtual void SetWidth(double w); 
        virtual void SetHeight(double h);
}; 


void Square :: SetWidth(double w) {
    Rectangle :: SetWidth(w); 
    Rectangle :: SetHeight(w); 
}

void Square :: SetHeight(double h) {
    Rectangle :: SetHeight(h); 
    Rectangle :: SetWidth(h); 
}
```

### 본질적인 문제
위 코드는 Square에 대한 모순 없이 잘 동작한다.

하지만 모든 사용자 코드에 대해서 모순이 없는 것은 아니다.

```cpp
void g(Rectangle& r){
    r.SetWidth(5);
    r.SetHeight(4);
    assert(r.Area() == 20);
}
```

위 함수는 Square 파생클래스에 대해서는 동작하지 않는다.

본질적인 문제는 함수 g의 작성자가 Rectangle의 가로길이를 설정하는 것이 세로길이까지 설정할 것이라고 생각하지 못한다는 것이다.  
(Rectangle의 SetWidth와 SetHeight가 가로, 세로의 길이를 독립적으로 설정할 것이라고 생각하는 것이 일반적일 것이다.)

이런 함수에서는 Square가 Rectangle과 치환 가능하지 않고, Square와 Rectangle 사이의 관계는 LCP를 위반한다.  

결론적으로 함수 g는 Square/Rectnagle 계층 구조에 대해 취약하다.

Square는 불변식을 위반하지 않았음에도 Rectangle에서 Square를 파생시킴으로써 Rectangle의 불변식을 위반하게 되었다.

### 유효성은 본래 갖추어진 것이 아니다.
위 예시로 `LSP는 모델만 별개로 보고, 그 모델의 유효성을 충분히 검증할 수 없다` 라는 결론을 얻을 수 있따.

특정 설계가 적절한지 아닌지를 판단할때는 별개로 봐선 판단할 수 없다.  
그 설계를 사용자가 택한 합리적인 가정의 관점에서 봐야 할 수 있다.

### 'IS-A'는 행위에 대한 것이다.
Rectangle, Square는 IS-A관계인가?

위 함수 g의 작성자의 관점에서 볼때 Square는 절대 Rectangle이 아니다.

Squre객체의 `행위`가 g가 기대하는 Rectangle객체의 행위와 일치하지 않기 때문이다.

### 계약에 의한 설계
위와 같이 SetWidth, SetHeight가 가로, 세로 길이설정에 독립적이라는 것은 `합리적 추정`이다.

이런 합리적 추정을 명시적으로 만들어 LSP를 강제하할 수 있다.

이를 계약에 의한 설계(DBC, design by contract)라고 한다.

DBC를 통해 클래스의 계약사항을 명시적으로 정할 수 있따.

이 계약은 각 메서드의 사전조건과 사후조건을 선언하는 것으로 구체화된다.

Rectangle 클래스의 SetWidth를 예시로 들면..

Rectangle::SetWidth(double w)  
사후조건 : `assert((itsWidth == w) && (itsHeight == old.itsHeight));` (old는 함수 호출 이전의 Rectangle)

**사전조건과 사후조건에 대한 규칙**
파생클래스에서 원래 사전조건과 같거나 더 약한 수준에서 그것을 대체할 수 있고,  
원래 사후조건과 같거나 더 강한 수준에서 그것을 대체할 수 있다.

즉, 사용자는 기반 클래스의 사전조건과 사후조건만 알 수 있으며, 기반클래스만 알아도 된다.

사용자는 파생된 클래스가 기반클래스가 요구하는 것보다 더 강한 사전조건을 따를 것이라 기대할 수 없고,  
파생 클래스는 기반클래스의 모든 사후조건을 따라야 한다.

이전 예시의 Square::SetWidth(double w)의 사후조건은 `itsHeight == old.itsHeight`를 만족하지 않기 때문에 더 약한 사후조건이며, 기반클래스의 계약을 위반하게 된다.

### 단위 테스트에서의 계약사항 구체화하기
계약은 단위테스트를 통해서도 구체화될 수 있다.

단위테스트를 통해 사용자코드에서 그 클래스에 대한 합리적 추정이 무엇인지 알 수 있다.

### 실제 예
LSP를 위반한 실졔 예시

이전 예시들의 실제 사례, 패스

p.154 ~


### 파생 대신 공통 인자 추출하기
난해한 상속의 예시인 Line(직선), LineSegment(선분)

- line.h
```cpp
...
class Line {
    public :
            Line(const Point& p1, const Point& p2);
            double GetSlope() const
            double GetIntercept() const //Y절편
            Point GetP1() const{
                return itsP1;
            }
            Point GetP2() const{
                return itsP2;
            }
            virtual bool IsOn(const Point &) const
            
    private :
        Point itsP1;
        Point itsP2;
};
...
```

- lineseg.h
```cpp
...
class LineSegment : public Line {
    public :
        LineSegment(const Point& p1, const Point& p2);
        double GetLength() const
        virtual bool IsOn(const Point&) const
};
...
```

위 코드를 보면 LineSegment는 Line의 모든 멤버변수, 멤버함수를 필요로한다.  
추가로 GetLength가 추가되었고 IsOn함수를 오버라이드 한다.

하지만 이 두 클래스도 LSP를 위반한다.

Line의 사용자는 직선상의 모든 점이 이 선 안에 포함되기를 기대한다.

따라서 Y절편을 반환하는 GetIntercept()함수에 의해 반환된 점은 직선상에 있기 때문에 `IsOn(GetIntercept()) == true`임이 기대된다.

하지만 LineSegment에서 이 식은 실패한다. (LineSegment는 선분이기에 y축을 지나지 않는 경우가 있으므로..)

드물게 설계를 고쳐서 완벽한 LSP를 지키는것보다 이런 미묘한 문제를 놔두는 것이 적절한 경우도 있다.  
-> 완벽한 설계보다 타협이 유리한 경우도 있다

하지만 LSP를 가볍게 포기해선 안된다. (서브클래스를 개별적으로 다뤄야하며 복잡해지기 때문에..)


--- 

위 Line, LineSegment 예에서는 두 클래스의 공통 원소를 추출하여 추상 기반 클래스를 만들어 해결할 수 있다.

- ex) Line, LineSegment에서 공통인자를 추출하여 만든 기반클래스 LinearObject
```cpp
class Linearobject {
    public :
        LinearObject(const Point& p1, const Point& p2);
        
        double GetSlope() const;
        double GetIntercept() const;
        
        Point GetP1() const {
            return istP1;
        };
        
        Point GetP2() const {
            return itsP2;
        };
        
        virtual int IsOn(const Point&) const = 0;
        
    private :
        Point itsP1;
        Point itsP2;
};
```

- line.h
```
class Line : public LinearObject {
    public :
        Line(const Point& p1, const Point$ p2);
        virtual bool IsOn(const Point&) const;
};
```

- lineseg.h
```cpp
class LineSegment : public LinearObject {
    public :
        LineSegment(const Point& p1, const Point$ p2);
        
        double GetLength() const;
        virtual bool IsOn(const Point&) const;
};
```

LinearObject는 Line과 LineSegment 모두를 표현한다.

LinearObject의 사용자는 자신이 사용하는 객체의 범위를 안다고 가정할 수 없으므로 Line이든 LinSegment든 어떤 것이든 받아들일 수 있다.

또한 Line사용자는 절대 LineSegment를 다룰 필요가 없다.

공통 인자 추출에 대해 말하길..  
`어떤 클래스 집합이 모두 같은 책임을 진다면, 공통 슈퍼클래스에서 그 책임을 상속받아야 한다.`

### 휴리스틱과 규정
LSP 위반의 단서를 보여주는 간단한 휴리스틱(heuristic, 대충 어림짐작한다는..)이 있다.

기반클래스에서 어떻게든 기능성을 제거한 파생클래스에 대해 적용해야한다.

기반 클래스보다 덜한 동작을 하는 파생클래스는 보통 그 기반 클래스와 치환이 불가능하므로 LSP를 위반한다.


#### 파생 클래스에서의 퇴화 함수
예시..

f()라는 함수가 Derived 파생클래스에서 퇴화하는 예시이다. (작성자 f()함수는 Derived에서 필요하지 않다고 판단한 이유일 것이다..)

```java
public class Base{
	public void f() {/*일부코드*/}
}

public class Derived extends Base {
	public void f() {}
}
```

하지만 Base의 사용자는 f를 호출하면 안된다는 사실을 모르기때문에 LSP위반이 발생할 수 있다.

파생클래스에 퇴화함수가 존재한다고 해서 무조건 LSP를 위반하는 것은 아니지만 위반여부를 살펴볼만한 가치는 있다.

#### 파생클래스에서의 예외 발생
또 다른 예는,  
기반클래스에서 발생시키지 않는 예외를 파생클래스의 메서드에 추가하는 것이다.

기반클래스의 사용자가 예외를 기대하지 않는다면 파생클래스의 메서드에 예외를 추가했을때, 치환 가능하지 않다.

### 결론
LSP는 OCP를 가능하게 하는 주요 요인 중 하나이다.

LSP는 서브타입의 치환 가능성을 말하는데, 치환가능성은 일반적인 사고나 암암리에 의존할 수 있기 때문에 기반타입의 계약사항이 명시적으로 강제되지 않은 경우에는 코드에서 분명하고 뚜렷하게 나타나야 한다.(테스트 코드든, 어떤 명세로든..) 