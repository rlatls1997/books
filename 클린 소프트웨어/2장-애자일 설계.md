# 2. 애자일 설계

애자일(agile) - 기민함, 날렵함

애자일하게 소프트웨어를 만들어나가면 설계는 언제하나? 좋은 설계가 필요하지 않은가? 란 의문이 들 수 있음.

애자일은 미래의 구현과 구조보단 현재의 시스템에 초좀을 맞춘다.

#### 잘못된 설계의 증상

설계가 잘못되었을때 나타나는 증상

- 경직성 : 설계를 변경하기 어려움
- 취약성 : 설계가 망가지기 쉬움
- 부동성 : 설계를 재사용하기 어려움
- 점착성 : 제대로 동작하기 어려움
- 불필요한 복잡성 : 과도한 설계
- 불필요한 반복 : 마우스 남용
- 불투명성 : 혼란스러운 표현

이런 '코드의 악취'같은 문제를 피하기 위한 방법을 알아본다

#### 원칙
'코드의 악취'를 제거하고 현재 기능 집합에 대해 최적의 설계를 구성할 수 있도록 돕는 원칙도 알아본다

1. SRP : 단일 책임 원칙
2. OCP : 개방 폐쇄 원칙
3. LSP : 리스코프 치환 원칙
4. DIP : 의존 관계 역전 원칙
5. ISP : 인터페이스 분리 원칙

#### 악취와 원칙
보통 코드악취는 위와 같은 원칙을 위반했을때 발생한다.

하지만 원칙을 항상 따르는 것은 불필요한 복잡성을 높일 수 있다.

(꼭 필요할때만 적용하는 것이 베스트)


## Chapter 7. 애자일 설계란 무엇인가?
소프트웨어 설계에 대한 내용

### 소프트웨어에서 어떤 것이 잘못되는가?
소프트웨어는 시간이 지날수록 점점 망가지고 유지보수가 어려워진다.

이는 재설계의 필요로 이어지는데, 재설계는 성공하기 어렵다.(재설계를 하는 와중에도 시스템은 계속 발전하고 변경되기 때문에)

새로운 설계는 발전되고 변경될 도착점을 쫓아가야한다. 그래서 어렵다.

### 설계의 악취 : 부패하고있는 소프트웨어의 냄새
다음과 같은 냄새가 소프트웨어는 망가지고 있다는 지표이다.

1. 경직성 : 설계를 변경하기 어려움. 변경하려면 시스템의 다른 부분들까지 많이 변경해야함
2. 취약성 : 설계가 망가지기 쉬움. 변경하면 관련없는 부분이 망가짐
3. 부동성 : 설계를 재사용하기 어려움. 
4. 점착성 : 제대로 동작하기 어려움. 옳은 동작을 하는 것이 어려움 
5. 불필요한 복잡성 : 과도한 설계. 직접적인 효용이 전혀 없는 설계로 인한.. 
6. 불필요한 반복 : 마우스 남용. 단일 추상개념으로 통합할 수 있는 반복적인 구조가 설계에 포함됨. 
7. 불투명성 : 혼란스러운 표현. 잃고 이해하기 어려움

#### 1. 경직성
단순한 방법으로도 소프트웨어를 변경하기 어려운 경향. (한 군데를 수정하면 의존적인 모듈에서 단계적으로 수정이 발생하는..)

간단한 수정처럼 보여도 예상하지 못한 간접적인 영향때문에 작업시간 추정이 어렵다.

#### 2. 취약성
한 군데를 변경했을때 프로그램의 많은 부분이 잘못되는 경향.

#### 3. 부동성
다른 시스템에서 유용하게 쓸 수 있는 부분을 포함하고 있으나 그런 부분을 원래 시스템에서 분리하는 수고와 위험성이 큰 케이스.

#### 4. 점착성
`소프트웨어의 점착성`과 `환경의 점착성` 두 형태로 나눌 수 있다.

- 소프트웨어의 점착성

변경사항을 마주했을때 설계를 유지하며 변경하는 케이스가 있고, 설계를 수정하여 변경하는 케이스가 있다.

만약, 변경할 때 설계를 유지하는 방법이 더 어렵다면 설계의 점착성은 높아진다.

설계를 수정하여 변경하는 케이스는 잘못된 동작을 하게될 가능성이 높고, 올은 동작을 하기 힘들어진다.

이 때문에 프로그래머는 설계를 유지할 수 있는, 변경이 쉬운 설계가 필요한데 그렇지 않다면 점착성이 높은 것이다.

- 환경의 점착성

개발환경이 느리고 비효율적일때 발생한다.

컴파일 시간이 길거나, git에서 pull 받고 checkout하는 등의 동작이 느리거나..


점착성을 최소화하기 위해 설계를 유지하기 쉬운 시스템과 효율적인 프로젝트 환경이 필요하다.

#### 5. 불필요한 복잡성
현 시점에서 유용하지 않은 요소가 설계에 포함되어 있는 경우를 말한다.

개발자가 필요할 것으로 예상되는 기능이나 설계를 집어넣을때 발생하는데,

이게 미래의 변경에 대해 유연해질 것처럼 보여서 괜찮아보이지만 그렇지 않다.
 
사용되지 않는 구성요소들이 늘어나서 소프트웨어가 복잡하고 이해하기 어려워질 뿐이다.

#### 6. 불필요한 반복
시스템에서 반복되는 부분은 흔하게 발생한다.

어떤 작업자가 작성한 코드에서 필요한 부분을 추가해 다른 코드에 붙이는.. 등의 작업이 반복되면 조금씩 다른 형태로 반복되어 나타나게 되는데

이로인해 추상화된 개념을 잃게된다.

반복되는 부분을 찾아 적절한 추상화를 통해 이를 얿ㅅ애는 일은 시스템을 이해하고 유지보수하기 쉽게 만든다.

하지만 반복되는 부분을 찾아서 시스템을 변경하는 것은 모든 반복되는 부분에서 조금씩 다른 부분이 있기 때문에 되다.

#### 7. 불투명성
모듈을 이해하기 어려운 경향을 말한다.

발전하는 코드에 따라 시간이 지날수록 코드가 불명료해지는 경향이 있는데, 불투명성을 최소로 유지하기 위해 지속적인 노력이 필요하다.

불투명성의 최소화를 위해 읽는 사람의 입장에서 생각하고, 코드를 리팩토링하는데에 노력을 기울여야한다.

그리고 타인이 자신의 코드를 검토하도록 할 필요학 있다.

### 무엇이 소프트웨어의 부패를 촉진하는가?
애자일이 아닌 환경에선, 초기 설계에 없었던 요구사항 변경때문에 설계가 퇴화하게 된다.

요구사항의 변경은 보통 빠르게 이루어져야 해서 기존 설계에 익숙하지 않은 개발자가 작업을 맡게되는 까닭에,

기존 설계를 위반하는 변경이 축적되어 코드악취를 풍기게 된다.

하지만, 요구사항은 변경되는게 일반적이고 계속되는 요구사항 변경때문에 설계가 실패한다면 설계와 방식에 문제가 있는 것이다.

### 애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다.
애자일팀은 시스템의 설계를 가능한 단순하게 유지한다.

그리고 이를 단위테스트와 인수테스트로 뒷받침한다.

이런 작업을 통해 설계를 유연하고 변경하기 쉽게 유지하여 변경되는 요규사항에 맞춰 그 시점에 가장 적합한 설계를 가진 시스템을 만들어낸다.

### 'Copy'프로그램
프로그램을 작성하면서 요구사항이 변경되고, 추가됨에 따라 코드냄새가 발생. 이에 따라 설계를 개선하는.. 예시. 패스

p.115~

### 가능한 한 좋은 상태로 설계 유지하기
애자일에서 개발가는 설계를 가능한 적절하고 명료한 상태로 유지하기 위해 애쓴다.

코드에 부패가 발생하도록 놔두지 않는다.

어느 한 군데에서 발생하는 코드 냄새를 방치하면 나중엔 걷잡을 수 없이 퍼져나간다.

### 결론
애자일 설계는 과정이다.

원칙, 패턴, 소프트웨어의 구조, 가독성을 향상하기 위한 방식의 연속적인 적용이며,

설계를 간단하고 명료하고 표현적으로 유지하려는 노력이다.


## Chapter 8. 단일 책임 원칙(SRP)
단일 책임 원칙 ≈ 응집도

모듈이나 클래스의 변경을 야기하는 응집력에 대한 내용

### 단일 책임 원칙(SRP)
`한 클래스는 단 한가지의 변경 이유만을 가져야 한다.`

책임의 분리가 중요한 이유는 각 책임이 변경의 축 이기 때문이다.

한 클래스가 하나 이상의 책임을 맡는다면, 
- 그 클래스를 변경할 하나 이상의 이유가 있게된다.
- 그 책임들은 결합되고 다른 책임을 충족시키는 클래스의 능력을 저하시킨다. 


<img src="https://github.com/user-attachments/assets/825665fc-77e6-4c14-9ddd-c109b2cc0873" width="600">

위는 Rectangle이 도형의 계산과, gui에 그림을 그리는 두 가지 역할을 하고 있다.

이런 SRP위반은 다음의 문제들을 유발한다.
- geometry 애플리케이션에 불필요한 GUI기능을 포함해야한다. 결국 GUI를 위한 파일도 같이 배포되어야 하며 컴파일시간과 메모리 영역을 소비하게된다.
- Graphic 애플리케이션에서의 변경이 Rectangle의 변경을 유발한다면 geometry 애플리케이션도 재빌드, 재배포 해야할수도 있다. 그렇지 않으면 애플리케이션이 오동작 할수도 있다. 

<img src="https://github.com/user-attachments/assets/bade859c-b7c3-43cb-b560-592a465f9ee8" width="600">

좀 더 나은 설계는 책임을 서로 다른 클래스로 분리해넣는 것이다.

분리한 이후에는 gui가 어떻게 그려지든 geometic 애플리케이션에 영향을 주지 않는다.

### 책임이란 무엇인가?
책임 = 변경을 위한 이유

클래스를 변경하기 위한 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고 있는 것이다.

예를 들어보면..

- ex) SRP를 위반한 interface 예
```java
interface Modem {
	public void dial(Stringno);
	public void hangup();
	public void send(char c);
	public char recv();
}
```

위 케이스는 연결관리(dial, hangup), 데이터통신(send, recv)라는 두 개의 책임이 있다.

하지만, 두 책임을 항상 나눠야 하는것은 아니다.

두 책임이 분리되어야 하는지는 애플리케이션이 어떻게 바뀌느냐에 달려있는데

만약 애플리케이션이 연결 함수(dial, hangup)의 시그니처에 영향을 주는 방식으로 바뀐다면, 이를 호출하는 클래스는 자주 재컴파일되고 재배포 되어야 할것이므로, 이 설계는 `경직성`의 악취를 풍기게 된다.

이런 경우라면 아래와 같이 두 책임을 서로 나눠야한다
```java
interface DataChannel {
	public void send(char c);
	public char recv();
}

interface Connection {
	public void dial(Stringno);
	public void hangup();
}
```

반면에, 애플리케이션이 서로 다른 시점에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면 굳이 분리할 필요는 없다.

이런 경우 분리하면 오히려 `불필요한 복잡성`만 생기게 된다.

결론은, `변경의 축은 변경이 실제로 일어날 때만 변경의 축이다.`

아무 증상도 없는데 SRP나 다른 원칙을 적용하는 것은 좋지 않다.

### 결합된 책임 분리하기
위 DataChannel, Connection 두 인터페이스를 모두 결합한 클래스가 존재할 수 있다. 

이런 클래스가 바람직해보이지 않을 수 있는데, 모든 의존성이 필요악일 수 있다.

하드웨어나 OS의 세부적인 사항과 관련된 이유로 인해 책임이 결합되도록 만드는 경우가 종종 있다.

그리고 결국 의존하는것은 이 클래스가 아닌 위 두 인터페이스이기 때문에 이 클래스는 존재한다는 사실을 알 필요가 없으며 애플리케이션의 나머지 부분을 오염시키지도 않는다.

### 영속성

<img src="https://github.com/user-attachments/assets/51be01e6-3856-467f-8d9d-95fd935df070" width="600">

위 그림은 SRP를 위반한 사례인데,

Employee클래스는 비즈니스적인 규칙과 영속성제어를 포함한다.

이 두 책임은 서로 어울리지 않고 비즈니스적인 규칙과 영속성이 바뀌는 이유도 서로 다르다.

이렇게 경직성(설계를 변경하기 어려움), 취약성(설계가 망가지기 쉬움)이 강해진 경우 퍼사드나 프록시 패턴을 사용해서 두 책임이 분리되도록 리팩토링 해야한다.

### 결론
책임을 결합하는 것은 시스템을 만들면서 자연스럽게 발생한다. 이런 책임을 분리하는 것이 중요하다.

## Chapter 9. 개방 폐쇄 원칙(OCP)
### 개발 폐쇄 원칙
`소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.`

프로그램 한 군데를 변경했을때 의존적인 모듈에서 단계적인 변경을 불러일으키면 이 설계는 `경직성`의 악취를 풍긴다.

OCP는 나중에 일어날 변경이 더이상 수정을 유발하지 않게 충고해주며, OCP가 잘 적용되었다면 원래 코드의 수정이 아닌 새로운 코드를 덧붙이는 방식의 변경이 용이해진다.

### 상세 설명
OCP를 따르는 모듈은 다음 속성을 같는다.
1. 확장에 대해 열려 있다.

모듈의 행위가 확장될 수 있음을 의미한다. 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 행위를 추가해서 모듈을 확장할 수 있음을 의미한다.

2. 수정에 대해 닫혀 있다.

모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

### 해결책은 추상화다
추상화를 통해 고정되기는 해도 제한되지 않는 가능한 행위의 묶음을 표현할 수 있다.

OCP를 따르는 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀있을 수 있고,

그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

예를 보면..

ex) OCP를 따르지 않는 셜계
<img src="https://github.com/user-attachments/assets/378c987a-fba6-42a2-a486-aa43760c5030" width="600">

위 그림은 Client클래스가 Server클래스를 사용하는 예이다.

만약 Client가 다른 Server객체를 사용하게 하려면 Client클래스에서 새로운 Server클래스를 지정하도록 변경이 필요하다.


ex) OCP를 따르는 설계
<img src="https://github.com/user-attachments/assets/216b3c09-d12a-4a9a-91dc-4ddb4c66cffd" width="600">

위 그림에서 Client는 ClientInterface라는 추상화에 의존한다.

Server클래스는 ClientInterface의 파생 클래스이다.

만약 Client가 다른 Server클래스를 사용하려면 Client클래스의 변경 없이 ClientIntegerface클래스의 새 파생 클래스를 생성하면 된다.


**네이밍**
왜 위 그림에서 interface 이름에 Server가 아닌 Client가 들어갈까?

추상클래스는 자신을 구현하는 클래스보다도 클라이언트에 더 밀접하게 관련되어 있기 때문이다. 

### Shape 애플리케이션
OCP를 설명하기 위한 예제

원, 사각형을 그릴 수 있는 애플리케이션이 있다.

프로그램은 원과 사각형의 목록을 순서대로 따라가며 각각 그려야 한다.

### OCP 위반
ex) OCP를 위반한 예
```cpp
-- shape.h --

enum ShapeType {circle, square}

struct Shape{
    ShapeType itsType;
}

-- circle.h --

struct Circle {
    ShapeType itsType;
    double itsRadius;
    Point itsCenter;
}

void DrawCircle(struct Circle*);

-- square.h --

struct Square{
    ShapeType itsType;
    double itsSide;
    Point itsTopLeft;
}

void DrawSquare(struct Square*)

-- drawAllShapes.cc --

typedef struct Shape *ShapePointer;

void DrawAllShapes(ShapePointer list[], int n){
    int i;
    for(i=0;i<n;i++){
        struct Shape* s = list[i];
        switch(s->itsType){
            case square:
                DrawSquare((struct Square*) s);
                break
            case circle:
                DrawCircle((struct Circle*) s);
                break
        }
    }
}
```

위 예제에서 DrawAllShapes 함수는 새로운 도형 종류에 대해 닫혀 있을 수 없기 때문에 OCP를 따르지 않는다.(switch문에 새로운 도형의 분기가 필요함)

또한 도형을 추가하기 위해 ShapeType enum에 새 멤버가 필요하고 이 enum변수의 선언에 모든 도형이 의존하기 때문에 이 모두를 다시 컴파일 해야하고 Shpe에 의존하는 모든 모듈도 마찬가지이다.

### OCP 따르기
```cpp
class Shape{
    public : virtual void Draw() const = 0;
}

class Square : public Shape {
    public : virtual void Draw() const
}

class Circle : public Shape {
    public : virtual void Draw() const
}

void DrawAllShapes(vector<Shape*> & list) {
    vector<Shape*> :: iterator i;
    for(i = list.begin();i != list.end(); i++){
        (*i) -> Draw();
    }
}
```

위 예제에서는 DrawAllShapes 함수의 행위를 확장해서 새로운 도형을 그리고 싶다면 Shape 클래스의 새로운 파생클래스만 만들면 된다.

DrawAllShapes함수를 변경할 필요가 없어서 이는 OCP를 따른다. (수정 없이 확장 가능)

또한 새 도형 클래스를 추가한다고 해도 어떤 모듈에도 영향을 주지 않는다.

설계의 잘못된 증상 측면에서 보면..
- 경직성 : Shape의 새 파생클래스의 인스턴스를 실제로 생성하는 모듈을 제외하면 수정되어야 하는 모듈이 없고, 외에는 Shape에 의존하기 때문에 새 파생클래스를 몰라도 된다.
- 취약성 : 새로운 도형을 추가하는 것이 다른 애플리케이션 코드 변경 없이 새 파생클래스를 만들고 그 함수를 구현하는 것뿐이기 때문에 취약하지 않다 
- 부동성 : DrawAllShapes는 Shape 파생클래스의 편승 없이 다른 애플리케이션에서도 재활용될 수 있다. 따라서 부동성이 없다.

### 예상과 '자연스러운' 구조
예를 들어서 DrawAllShapes에서 도형을 그릴때 `원이 항상 사각형보다 먼저 그려져야한다`는 조건이 있으면 변경에 닫혀 있지 않게 된다.

이렇게 순서가 도형의 종류보다 더 중요한 시스템이서는 위와 같은 모델이 자연스럽지 않다.

모든 상황에서 자연스러운 모델은 없다.

또한 OCP를 따르는 것은 비용이 많이 든다. (적절한 추상화 만들기, 소프트웨어 설계의 복잡성 증가..)

따라서 경험과 상식을 통해 변경이 일어날 때까지 기다린 후 그에 따라 적절한 조치를 취하는것이 바람직하다.

### '올가미'놓기
발생가능한 변경에 '올가미'를 놓는 것(미리 준비하는..)은 소프트웨어를 유연하게 만들어줄 것이라 생각된다.

하지만 실제론 그렇지 않고 유지보사되어야 하는 `불필요한 복잡성`만 발생시킨다.

처음에는 변경이 되지 않을것이라 생각하고 작성하고, 변경이 일어나면 그 때 비슷한 변경으로부터 유연한 추상화를 구현하는 것이 좋다.

**변경 촉진하기**
이런 변경은 짧은 텀에 빈번하게 일어날 수록 적절한 추상화를 만드는 것이 쉬워진다.

이런 변경을 촉진하기 위한 방법으로는..
- 테스트를 먼저 작성한다. 테스트를 먼저 작성함으로써 시스템을 테스트 가능하게 만드는 추상화를 만들게 된다.
- 아주 짧은 주기로 개발한다
- 기반구조보다 기능 요소를 먼저 개발하고, 이 기능요소를 이해당사자에게 자주 보여준다.
- 가장 중요한 기능 요소를 먼저 개발한다.
- 소프트웨어를 빨리, 자주 릴리즈하고 사용자가 확인할 수 있게 한다.

### 명시적인 폐쇄를 위해 추상화 사용하기
아까 나왔던 순서의 변경에 대해 DrawAllShapes함수를 닫는 방법은?

폐쇄는 추상화에 기반을 둔다. 따라서 `순서 추상화`가 필요하다.

2개의 객체가 주어졌을때 어느 것을 먼저 그려야 하는지를 Precedes라는 메서드 하나를 추가했다.

ex) Precedes라는 순서 추상화 메서드가 추가된 예
```cpp
class Shape{
    public : virtual void Draw() const = 0;
    virtual bool Precedes(const Shape&) const = 0;
    bool operator<(const Shape& s) {
        return Precedes(s)
    }
}

template <typename P> class Lessp{
// 포인터의 컨테이너를 정렬하기 위한 유틸리티
    public : bool operator() (const P p, const P q) {
        return (*p) < (*q);
    }
}

void DrawAllShapes(vector<Shape*>& list) {
    vector<Shape*> orderedList = list;
    sort(orderedList.begin(), orderedList.end(), Lessp<Shape*>());
    vector<Shape*> :: const_iterator i;
    for(i = orderedList.begin();i != orderedList.end(); i++){
        (*i) -> Draw();
    }
}

```
ex) Circle::Precedes 메서드 구현 예
```cpp
bool Circle :: Precedes(const Shape& s) const {
    if(dynamic_cas<Suqre*>(s))
        return true
    else
        return false
}
```

하지만 순서를 지정하기 위해 Shape의 다른 파생클레스는 Precedes메서드를 Override해야하므로 OCP를 따르지 않는다.

즉, Shape의 새로운 파생 클래스에 대해 닫을 수 있는 방법이 없다.

Shape에 새로운 파생 클래스가 생성될 때마다, 모든 Precedes메서드는 변경되어야 한다.

### 폐쇄를 위해 '데이터 주도적'접근 방식 사용하기
만약 Shape의 파생클래스가 서로에 대해 아는 것을 막는다면 테이블 주도적 접근 방식(table-driven approach)을 사용할 수 있다.

ex) 
```cpp
# include <typeinfo>
# include <string>
# include <iostream>

using namespace std;

class Shape{
    public : virtual void Draw() const = 0;
    bool Precedes(const Shape&) const = 0;
    bool operator<(const Shape& s) {
        return Precedes(s)
    }
    private : static const char* typeOrderTable[];
}

const char* Shape :: typeOrderTable[] = {typeid(Circle).name(), typeid(Square).name(), 0}
// 이 함수는 테이블에서 클래스 이름을 찾는다.
// 테이블은 그려질 도형의 순서를 정의한다.
// 발견되지 않은 도형은 언제나 발견된 도형에 우선한다.

bool Shape :: Precedes(const Shape& s) const {
    const char* thisType = typeid(*this).name()
    const char* argType = typeid(s).name();
    bool done = false;
    int thisOrd = -1;
    int argOrd = -1;
    
    for(int i=0;!done;i++){
        const char* tableEntry = typeOrderTable[i];
        if(tableEntry != 0) {
            if(strcmp(tableEntry, thisType) == 0) {
                thisOrd = i;
            }
            if(strcmp(tableEntry, argType) == 0) {
                argOrd = i;
            }
            if (argOrd >= 0 && thisOrd >= 0) {
                done = true;
            }
        }else
            done = true;
        }
    }
    return thisOrd < argOld;
}
```

위 접근방식으로 DrawAllShapes를 일반적인 순서문제에 대해 닫을 수 있다.

그리고 Shape의 파생 클래스 각각을 새 Shape 파생클래스 추가에 따라 정렬하는 정책의 변화에 대해서도 닫을 수 있다.

(물론 Shape의 순서에 대해서 typeOrderTable은 닫혀있지 않다.)

### 결론
추상화를 통해 유연성, 재사용성, 유지보수성을 얻을 수 있으나, 모든 부분에 마구 추상화를 적용하는 것도 좋지는 않다.

자주 변경되는 부분에만 추상화를 적용하기 위한 노력이 필요하다.