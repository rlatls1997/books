# 8. 메소드
메소드를 통해 해결하려눈 문제는 무엇인가?

- 로직의 연관성 표현 : 프로그램 로직을 여러개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다.
코드를 읽는 사람에게 메소드 A와 메소드 B는 서로 깊은 연관성을 지니지 않았다는 사실을 알게해준다.

- 로직의 목적 표현  : 메서드 이름을 통해 세부 구현을 알지 않아도 로직의 목적을 알 수 있다.

- 재사용 : 재사용 문제를 해결할 수 있다.


방대한 연산을 여러개의 메소드로 잘 나누는 작업은 어렵다.

메서드를 나눌 때 메서드의 크기, 목적, 이름 등을 잘 고려해야한다.
</br>짧은 메서드가 너무 많으면, 각 메서드에서 뭘 하는지 파악하기 어렵다
</br>메서드의 수가 너무 적다면 중복구현이 많아지고 유연성이 떨어진다.

반복적으로 필요한 기능에 대해 메서드를 만드는 것이 좋다.

## 1. 조합 메서드
추상화 수준이 비슷한 메서드 호출로 하나의 메서드를 구상하라

```java
void compute() {
    input();
    flags != 0x0080;
    output();
}
```

위 코드와 같이 추상화 수준이 바뀌면 흐름이 깨져 읽기 힘들다.
</br>추상화 수준이 비슷한 메서드를 호출하도록 구성하자.

메서드를 읽을때 메서드의 길이도 중요하다.
</br>전체 구조를 읽을때는 긴 메서드가 좋다.
</br>하지만 세부 구현을 이해하기에는 밀접한 코드만 모아놓은 짧은 메서드가 좋다.
</br>(일반적으로 5~15줄이 읽기 좋다)

적당한 크기로 메서드를 작성하면 하위클래스에서 코드를 복사하거나 여러 개의 메서드를 오버라이드 하거나 하지 않고 쉽게 오버라이드가 가능하다.

## 2. 의도 제시형 이름
메서드 사용자는 메서드 이름을 통해 메서드의 의도를 쉽게 파악할 수 있어야한다.

구현 전략이 메서드 이름에 부가정보로 들어가기도 한다.
```java
Customer.linearCustomerSearch(String id)
```

하지만 구현전략이 사용자에게 중요하지 않다면 이런 정보를 전달하지 않는게 더 좋을 수 있다.
</br>세부 구현 전략은 메서드 본문을 읽어서 확인하면 된다.

사용자 관점에서 메서드 이름을 짓자.
```java
Customer.find(String id)
Customer.fastFind(String id)
```

사용자 관점에서는 세부 구현 사항이 중요하지 않다.

메서드 이름은 메스드를 호출하는 코드가 표현하려는 바에 도움이 될 수 있어야 한다.

## 3. 메서드 가시성
public, protected, default, private 네 가지 접근지정자를 사용하여 가시성 선택 가능

메서드 가시성을 선택할때 고려할 사항으로는 
1. 미래의 유연성

가시성이 낮을 수록 미래에 수정하는데에 있어서 유리하다

2. 객체의 사용성

노출된 인터페이스가 많지 않은 객체를 사용하는 쪽에서 필요 이상으로 많은 작업이 요구된다.


가시성을 낮춰서 미래의 유연성을 확보할 수 있지만, 우리가 관리하는 코드가 아닌 곳에서 노출된 인터페이스를 사용하는 경우 가시성을 조정하는 것이 문제가 될 수 있다.(외부 라이브러리 등에서..)

이런 경우에 가시성 수정을 신중히 해야하기 때문에 가시성이 결정된 후 수정하는데에는 큰 비용이 든다.

#### 메서드 4가지 가시성
- public : 어디서든
- protected : 같은 패키지 내 또는 하위클래스
- default(접근지정자 생략) : 같은 패키지 내
- private : 캍은 클래스 내


#### 가시성 선택
먼저 가장 제한적인 가시성 선택 후 필요에 따라 조금씩 높이자.

가시성이 불필요하게 높다면 가시성을 낮추자.

가시성을 낮출때는 다른 동작하는 코드를 망가뜨리는 것이 아닌지 확인해야한다.


#### final 메서드
메서드를 final로 선언하여 오버라이딩을 금지할 수 있다.

메서드를 변경하는 것이 복잡하고 마묘한 결과를 유발하는경우 final로 선언하는것이 정당화될 수 있다.

### static 메서드
메서드를 static으로 선언하면 다른 객체에서 해당 클래스의 인스턴스에 접근할 수 없는 경우에도 메서드에 접근할 수 있다.(객체 생성없이 호출)


## 4. 메서드 객체
메서드 객체는 메서드를 읽기 쉽게, 세부구현전달이 쉽도록 해준다.

동작하는 코드가 나온 후에 사용하는것이 보통이며 코드가 복잡할수록 효과가 크다.

메서드 객체를 생성할때는 먼저 많은 수의 파라미터와 임시 변수를 사용하는 긴 메서드를 찾자.

#### 메서드 객체를 생성하는 순서
1. 메서드 이름을 따러 클래스 이름을 정한다. ex) complexCalculation() -> ComplexCalculator
2. 메서드에서 사용하는 각 파라미터, 지역변수, 필드에 대해 새로운 객체상의 필드를 생성한다.
3. 본래 메서드의 파라미터와 메서드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다.
4. 본래 메서드를 새로운 클래스의 calculate()라는 메서드로 복사한다. (기존 메서드의 파라미터, 지역변수, 필드로 사용된 값들은 객체의 필드가 됨)
5. 기존 메서드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다.
6. 본래 메서드에서 필드를 설정하는 부분이 있으면 calculate()가 반환된 후 설정해준다.


메서드 객체를 사용하려고 보니 이미 기존 객체에서 메서드 분화를 상당히 진행해놓은 경우라면,
</br>모든 연산을 한 메서드에 몰아넣고 메서드 객체를 사용하자.


## 5. 오버라이드
오버라이드를 사용하여 변형 메서드를 명확하게 표현할 수 있다.

final메서드만 아니라면 기존 연산에 대한 변형이 가능하다.


오버라이딩을 할 때,
</br>상위클래스의 메서드는 하위클래스 중 같은 이름의 메서드에서만 호출하는 것이 좋다.

하위클래스에서 상위클래스의 여러 메서드를 자유롭게 혼합해서 사용하면 클래스의 흐름을 이해하기 어렵고 오류를 포함할 가능성이 높다.

하나의 메서드에서 여러 상위클래스 메서드를 호출해야하는 경우라면, 제어흐름의 재구성이 필요하다.

너무방대한 상위클래스 메서드는 다음과 같은 딜레마를 낳는다.
- 하위클래스에 상위클래스 코드를 복사해넣은 뒤 수정할 것인가? -> 상위클래스 메서드가 수정될 때 하위클래스 메서드까지 관리하기 어렵다
- 다른 방식을 사용해서 변형을 표현할 것인가?

## 6. 오버로드
서로 다른 파라미터를 사용하여 이름이 같은 메서드를 선언할 수 있다.

오버로딩 시 이런 특징의 문제점은 메서드 이름뿐만 아니라 파라미터도 유심히 살펴봐야 한다는 것이다.
</br>오버로드가 너무 복잡해지면 사용할때 어떤 메서드가 호출될지 알기 위해 오버로드 규칙을 알아내야한다.

오버로딩은 파라미터 타입만 다를 뿐 같은 연산을 수행해야한다.
</br>메서드마다 다른 반환타입을 사용하면 읽기가 너무 어려워진다.
</br>의도가 다르다면 다른 이름을 사용하여 메서드를 만들자.

## 7. 메서드 반환 타입
메서드 반환타입은 메서드가 프로시저인지, 특정 객체를 반환하는 함수인지 구별해준다.
</br>void 반환타입을 통해 별도의 키워드 없이 프로시저를 함수와 구별할 수 있따.

가급적 메서드의 적용 범위를 넓히기 위해 의도를 드러낼 수 있는 가장 추상적인 타입을 사용하자.
</br>이렇게 하여 구체적인 반환 클래스의 타입을 유연하게 변경할 수 있다.

## 8. 메서드 주석
코드만으로 분명하지 않은 정보는 주석을 사용해서 전달하자.

주석을 작성하고 코드와 주석간의 일관성을 유지하는데에는 노력이 필요하다
</br>노력이 정당화될 수 있는 경우에만 주석을 사용하자.

서로 다른 두 메서드 호출 시 순서가 중요한 경우 등 메서드 단위로 주석을 넣기 모호한 경우가 있다. 
</br>이런 경우 주석 대신 테스트를 통해 이런 내용을 전달 할 수 있다.(잘못된 순서로 메서드가 호출되면 예외가 발생하는지 테스트하는..)

## 9. 도우미 메서드
도우미 메서드의 목적은 관련도가 떨어지는 세부 구현을 숨기고 메서드 이름을 통해 의도를 나타내어 복잡하고 거대한 연산코드를 읽기 쉽게 하기 위함이다.

도우미메서드를 사용했는데 메서드의 로직이 불명확해지는 경우 도우미메서드를 제거하라
</br>모든 도우미 메서드를 인라인으로 변경하고 새 시각에서 다시 메서드를 분리하라

## 10. 디버그 출력 메서드
객체를 문자열로 나타내면 사용자에게 표현할때 편리하고 저장 후 다시 읽어와서 사용하기에도 좋고, 프로그래머에게 객체의 내부 구현을 표현할 수도 있다.

toString()메서드는 공용메서드이므로 남용하기쉽다.
</br>toString()은 프로그래머에게 유용한 객체의 정보를 알려주기 위해서만 사용하자.
</br>그밖의 문자열 정보는 다른 메서드나 다른 클래스를 통해 표현하라

## 11. 변환
객체 A를 B로 변환해야할 때 어떻게 하는것이 좋을까?

변환을 효과적으로 표현하기 위해서는 다음을 고려해야한다.
- 변환이 얼마나 많이 필요한가? -> A객체를 B객체로 변환하는 경우만 있다면 간단한 방법으로..
- 변환을 편리하게 표현하기 위해 클래스간의 의존성이 생길 수 있다 -> 바람직하지 않음

a타입에서 b타입 새 객체를 생성하는 변환 말고 다른 방안도 있다.
- b타입으로 변환할때 b객체가 대신 b인터페이스를 구현
- 실제 변환을 하지 않고 두 객체간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드를 작성

## 12. 변환 메서드
기존 객체에 변환하려는 객체 타입을 반환하는 메서드를 추가해서 변환을 나타낼 수 있다.

- ex) 일반좌표와 극좌표를 구현하려고 하는 예
```java
class Polar {
    Cartesian asCartesian(){
        ...
    }
}
```

변환을 사용하는 이유는 다른 프로토콜을 사용하는 객체를 얻기 위함이다.
</br>변환을 다른 방식으로 구현하면 Polar와 Cartesian에서 각각 Point인터페이스를 구현하고 Polar에 getX(), getY()를 구현하면 상호간의 변환을 무시해도 된다.(변환할 필요가 없으니)


변환메서드는 읽기 쉽다는 장점이 있으나,
</br>변환메서드를 만들기 위해서는 원본 객체의 프로토콜을 변경해야 한다.(ex, 극좌표를 일반좌표로 변경하는..?)
</br>또한 원본객체, 대상객체 사이의 의존성을 생성한다.

만약 수십개의 변환 메서드가 있는 경우,
</br>해당 클래스 코드를 읽기는 매우 어렵다
</br>이런 경우 변환 대신 클라이언트 측에서 원본 객체를 다룰 수 있게 하는 편이 낫다.



## 13. 변환 생성자
변환 생성자는 원본 객체를 파라미터로 취해서 대상 객체를 반환한다.
</br>변환 생성자는 하나의 원본 객체를 여러 다른 대상 객체로 변환할 때 유용하다.

ex) File(String name), URL(String spec)...

구상클래스(구체클래스)가 아닌 클래스를 반환해서 변환을 구현하고 싶다면 변환 생성자를 좀 더 일반적인 타입을 반환하는 팰토리 메서드로 표현할 수 있다.


## 14. 생성
옛날 프로그램은 코드와 데이터가 마구 섞여있었다.
</br>이는 점차 수정을 어렵게 하고 예상치못한 결과를 초래했다.

초기 전력은 수정하기 힘든 큰 프로그램을 수정하기 쉽게 잘게(객체로) 나누는 것이었다.

의미있는 객체 생성을 위해 명확하고 직접적인 표현과 유연성 사이에서 균형을 잡아야한다.
</br>생성 구현패턴을 이용하여 객체만들기를 더 잘 표현할 수 있다.

## 15. 완결생성자
객체는 연산을 하기 위해 정보를 필요로 한다.
</br>생성자에서 연산을 할 수 있는 객체를 반환하도록 하자.

기본생성자와 setter메서드를 사용하여 객체를 생성하는것이 유연성을 높이는 경우가 있다.
</br>하지만 이는 읽는 사람 입장에서 객체가 올바로 동작하기 위해 어떤 파라미터들이 필요한지 알기 어렵다.
</br>하지만 필요한 인자를 모두 취하는 생성자가 있다면 어떤 값이 필요한지 바로 알 수 있다.

완결생성자를 사용할때는 모든 생성자가 동일한 하느의 생성자를 사용해서 모든 초기화를 하도록 하라.
</br>이렇게 하여 어떤 생성자를 사용해도 올바른 동작을 위해 필요한 부분을 적절히 설정할 수 있다.
```java
public class Point {
	private int x;
	private int y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	Point() {
		new Point(0, 0);
	}
}
```

## 16. 공장 메서드
정적메서드를 사용하여 객체를 생성할 수 있다.

생성자에 비해 다음 장점이 있다.
- 추상 타입을 반환할 수 있다.
- 의도가 담긴 이름을 가질 수 있다.

하지만 복잡성이 증가하므로 이득이 있을때만 사용하자.

공장메서드는 객체 생성 외에 어떤 작업이 일어나는지 의문을 갖게하기 때문에 코드를 읽는 시간을 늘리게 한다.
</br>객체생성만이 목적이라면 생성자를 사용하자.

## 17. 내부 공장
도우미 객체 생성을 전용으로 하고 싶지만 객체 생성 과정이 복잡하거나 하위 클래스에서 달라질 경우,
</br>새로운 객체를 생성하고 반환하는 메서드를 만드는 것이 좋다

내부 공장은 게으른 초기화를 사용하는 경우 자주 사용된다.

다음 게으른 초기화로 변수를 초기화하는 getter를 보자
```java
getX(){
    if(x = null)
        x = ...;
    return x;
}
```
위 코드는 너무 많은 내용을 전달한다.
</br>변수 x에 대한 연산이 복잡한 경우 내부 공장을 사용하는게 낫다.

```java
getX(){
    if(x = null)
        x = computeX();
    return x;
}
```

??

## 18. 컬렉션 접근자 메서드
컬렉션을 갖고 있는 객체의 경우 컬렉션에 대한 접근을 어떻게 제공할 것인가?

간단하게 getter로 넘길 수 있따.
```java
List<Book> getBooks(){
    return books;
}
```

사용하기엔 유연하나 사용자가 직접 컬렉션을 조작하게 되어 객체 내부 상태가 유효하지 않게 될 수 있다.
</br>또한 컬렉션에 대한 작업을 허용하면 해당 객체에 대한 의미있는 프로토콜을 만들 기회를 상실하게 된다.

해법으로 반환할때 수정불가능한 컬렉션 형태로 바꿔 전달할 수 있다.
```java
List<Book> getBooks(){
    return Collections.unmodifiableList(books);
}
```

하지만 이 방법은 누군가 컬렉션을 수정하려고 하면 예외가 발생하고 이런 문제는 디버깅하는데 비용이 많이 든다.

이런 방법대신 제한적이지만 의미있는 접근을 제공하는 메서드를 사용하자.
```java
int bookCount(){
    return books.size();
}
```

만약 컬렉션 원소에 하나씩 접근해야한다면 iterator를 반환하자
```java
Iterator getBooks(){
    return books.iterator();
}
```

클라이언트가 컬렉션 내용을 수정하는 것을 금지하려면 컬렉션 원소를 제거할 경우 예외를 던지는 iterator를 반환하자.(디버깅은 어렵다.)
```java
Iterator<Book> getBooks(){
    ...
    return new Iterator<Book>(){
        ...
        public void remove() {
            throw new ~~Exception();
        }
    }
}
```

## 19. 불린 설정 메서드
가장 간단하게는 setter를 사용할 수 있다.
```java
void setValid(boolean newState){
    ...
}
```
하지만 setter의 인지가 항상 상수값이라면 각 boolean 상태별로 메서드를 제공하여 인터페이스를 더 명확하게 할 수 있따
```java
void valid() {...
void invalid() {...
```

하지만 다음과 같이 다른 boolean값에 따라 분기로 호출되게 된다면 그냥 setter(boolean ~) 형태의 메서드를 제공하는 편이 낫다
```java
...
if(...){
    cache.valid()
}else{
    cache.invalid();
}
```

## 20. 질의 메서드
개체가 프로토콜을 통해 다른 객체의 결정을 도와야 하는 경우 be(is, was)동사나 have동사를 사용하라

어떤 객체가 다른 객체의 상태에 의존적인 로직을 많이 갖고있다면 이는 로직의 위치에 문제가 있는 것이다.
ex) 다음 경우 widget객체에 적당한 메서드를 넣어주는 편이 낫다
```java
if(widget.isVisible()){
    diwget.doSomthiont();
}else{
    widget.doSomethingElse();
}
```

## 21. 동등성 메서드
객체 동일성이 아닌 동등성을 비교해야하는 경우 equals()와 hashCode()를 구현하라
</br>동등한 객체는 같은 해쉬값을 가져야하므로 hashCode()의 구현에는 equals()구현에 쓰인 데이터만을 사용해야한다.


```java
public boolean equals(Object other){
    if(! other instanceof Instrument){
        return false;
    }
    
    Instrument instrument = (Instrument) other;
    return getSerialNumber().equals(instrument.getSerialNumber());
}
```

위 예제의 보호절처럼
</br>동등성 비교에는 임의의 2개의 객체를 사용할 수 있으므로 이를 대비해야한다

equals(), hashCode()를 사용하려면 규칙을 따라야한다. (재정의를 같이..)
</br>규칙을따르지 않으면 컬렉션 사용 시 객체에 접근을 못하는 등 문제가 발생할 수 있다.

동등성에 대한 고민을 피하기 위해,
</br>2개의 수정불가능한 객체가 동등하다면 둘은 언제나 같은 객체임을 보장해주는 기법을 사용할 수 있다.(동등한 객체 인스턴스를 한개로 유지)
ex) 팩터리매서드를 사용하여 동등한 객체 인스턴스가 하나만 존재하게끔 함
```java
static Instrument create(String serialNumber){
    if(cache.containsKey(serialNumber)){
        return cache.get(serialNumber);
    }
    
    Instrument result = new Instrument(serialNumber);
    cache.put(serialNumber, result);
    
    return result;
}
```

## 22. 취득 메서드
객체 상태에 대한 접근을 허용하는 방법으로 getter메서드를 쓸 수 있다.

여러 객체를 이용해 알고리즘을 구현하거나 다른 라이브러리에서 사용하는 경우 getter를 public으로 사용해야한다.

private getter는 게으른 초기화나 캐시를 구현하는 경우 유용할 수 있다.

## 23. 설정 메서드
필드값을 설정하는 메서드가 필요하다면 setter메서드를 사용하자

설정메서드의 이름은 의도가 아닌 구현에 의해 정해진다.
</br>설정 인터페이스를 통해 유용한 인터페이스를 구현할 수 있다면 설정 메서드를 사용하는 것도 괜찮다.

다음과 같이 인터페이스에 설정메서드를 포함하면 내부 구현을 노출하게 된다
```java
paragraph.setJustification(Paragraph.CENTERED);
```

반면 메서드의 목적에 따라 인터페이스 이름을 정하면 코드 읽기가 쉬워진다.
```java
paragraph.centered();

Paragraph:centered(){
	setJustification(CENTERED);
}
```

private setter를 사용하는 것은 의존적인 정보를 업데이트할때 유용하다.
(setter사용 시 다른 정보도 수정을 해야하는 경우..)
```java
private void setJustification(...){
    ...
    redisplay();
}
```

setter를 사용하면 코드에 문제가 발생하기 쉽다.
</br>가급적 외부에서의 setter사용을 피하자.

</br>객체 A가 객체 B의 내부 필드에 의존적인 경우 B를 고치면 A도 고쳐야 한다.
</br>이런 경우 로직과 데이터를 함께 배치하도록 코드를 바꾸는 것이 좋다.


## 24. 안전한 복사
getter, setter를 사용하면 앨리어스 문제(2개의 객체가 다른 객체에 대해 배타적인 접근권이 있다고 가정하는 것)가 발생할 수 있다.

이런 경우 객체를 반환하거나 저장하기 전에 복사본을 만들어서 문제를 피할 수 있다.
```java
List<Book> getBooks(){
	List<Book> result = new ArrayList<Book>();
	result.addAll(books);
	return result;
}
```

설정메서드도 안전한 복사를 통해 구현할 수 있다.
```java
void setBooks(List<Book> newBooks){
	books = new ArrayList<Book>();
	books.addAll(newBooks);
    }
```

안전한 복사를 남용하면 거대한 객체가 복사되어 성능이 저하되고,
</br>이는 결과적으로 코드사용자로부터 복사버전 대신 일반버전을 사용하게하여 앨리어스 문제를 야기하게 된다.

근본적인 해결책은 프로토콜을 더 의미있게 바꾸는 것이다.

안전한 복사는 통제할 수 없는 외부 접근에서 코드를 보호하는 일시적인 해결책일 뿐이다.
</br>변경불가능 객체와 적합한 조합 메서드사용을 통해 더 간결하고 도움이 되면서도 문제를 적게 발생시키는 인터페이스를 만들 수 있다.