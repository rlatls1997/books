# 9장. 컬렉션
컬렉션과 컬렉션의 주요기능, 컬렉션의 확장등에 대한 내용을 다룸

## 1. 메타포
컬렉션에는 여러 종류의 메타포가 녹아있다.

#### 컬렉션은 여러값을 가진 변수(multi-valued variable)
-> 컬렉션 변수는 여러 객체를 한번에 가리키는 역할을 한다.

자바의 경우 컬렉션을 별도의 객체로 취급하므로 여러 값을 가진 변수라는 정체성이 희미해진다.

컬렉션에 사용되는 다른 메타포는 컬렉션이 객체라는 것이다.

컬렉션이 여러값을 가진 변수라는 관점에서는,
</br>컬렉션에 값을 할당(원소의 추가, 삭제)할 수 있고, 값을 얻어올 수 있고 변수메시지를 보낼 수 있다.

컬렉션이 객체라는 관점에서는,
</br>컬렉션에 대해 값을 얻는 것도 가능하고, 인저로 전달하는 것도 가능하며, 동등성 테스트를 할 수도 있고, 메시지를 보낼 수도 있다.


- 참조호출

컬렉션은 객체로 구현되므로 인자로 전달할때 참조호출의 효과를 얻을 수 있는데,
</br>참조호출로 인해 사이드이펙트를 유발할 수 있고 디버깅이 어려워지는 문제가 있다.
</br>이런 상황을 피하기 위해 컬렉션사용에는 규범이 존재한다.


#### 컬렉션은 수학적 집합
컬렉션은 여러 객체의 모임이다. 컬렉션은 수학적 집합처럼 컬렉션 집합에 대해 집합의 크기를 구하거나 집합에 속해있는지 알아보는 연산을 제공한다.

하지만 수학적 집합과는 다르게 합집합, 교집합, 차집합, 여집합 등의 연산은 컬렉션에 적용되지 않는다. (기존 컬렉션을 바꾸지않고 새로 할당된 컬렉션 반환)



## 2. 이슈
- 코드 작성 원칙

원칙적으로 프로그램을 작성할때 정확하게 작성해야한다.

컬렉션은 여러가지 개념을 나타내기 때문에 가급적 가장 일반적인 인터페이스를 사용해서 선언하고, 가장 구체적인 구현클래스를 사용하는 것이 좋으나 이 원칙이 절대적인 것은 아니다.

같은 객처를 어느곳에서는 Iterable, 어느곳에선 Collection, List 이렇게 선언하면 코드읽기만 어렵고 이점이 없다. (모든곳에서 List로 선언하는 편이 훨씬 깔끔)

- 컬렉션 개념

크기 : 배열의 크기는 생성시 고정되지만 대부분의 컬렉션은 크기가 동적이다.

순서 : 원소간의 순서에 의미가 있는 경우, 순서를 보전하는 컬렉션을 사용해야 한다.

원소의 독자성(단일성) : 원소가 컬렉션에 속해있는지 여부만이 중요한 경우가 있을 수 있고, 또는 컬렉션에 어떤 원소가 몇번 나타나는지가 중요한 경우도 있다.

- 원소의 접근

컬렉션의 원소에 순차열람만을 사용할때가 있고 키를 통해 원소를 얻어오는 경우도 있다.

- 성능

컬렉션이 너무 커질때를 고려하여 프로그램 최적화를 위해 적당한 컬렉션을 사용할 필요가 있다.

보통 성능을 좋게하려면 가독성이나 유연성과 같은 코드품질을 희생해야한다. 이러한 희생을 최소화하는것이 중요하다.

성능에 초점을 맞춰 프로그램을 작성하다보면 지역적 변화의 원칙을 위배할 수 있다.(한 부분을 수정했을 때 다른부분의 성능이 떨어지는..)
</br>성능에 초점을 맞춰 프로그램을 수정할때 이런 부분을 주의해야한다.


## 3. 인터페이스
코드를 읽는 사람들은 인터페이스와 구현을 보고 여러 해답을 얻는다. (순서가 있는지, 중복을 허용하는지 등..)

여러 인터페이스에 대해 알아보자
- 배열
- Iterable
- Collection
- List
- Set
- SortedSet
- Map

#### 배열
크기가 고정되어 있고 원소접근방법이 용이하며 빠른 컬렉션. 

유연성이 떨어지지만 다른 컬렉션에 비해 시간, 공간 모든 면에서 효율적이기 때문에,
</br>성능이 중요한 대부분의 경우 다른 컬렉션을 사용하는 것이 낫지만, 성능이 중요하면 배열을 사용하는 것도 좋다.

#### Iterable
순차 열람을 지원하는 인터페이스.

컬렉션을 사용할때 클라이언트에세 컬렉션을 수정할 수 있는지에 대한 여부를 전달해야한다.
</br>Iterable과 Iterator로는 선언적으로 이런 내용을 전달하지 못한다. 
</br>Iterator를 갖고있다면 Iterable컬렉션에서 원소를 제거할 수 있다

즉 Iterable을 사용하면 원소를 추가하는것은 막을 수 있으나 원소가 지워질 위험이 있다.

원소가 지워지는 문제를 막기 위해 수정시 예외를 던지는 iterator를 반환하거나, 안전한 복사본을 반환하게 할 수 있다.

#### Collection
Iterable을 상속하며, 원수 추가, 삭제, 검색, 크기 측정 등의 메서드를 추가로 지원한다.

선언을 가급적 일반적인 인터페이스로 남겨두면 코드를 크게 바꾸지 않고서도 나중에 구현클래스를 쉽게 바꿀 수 있다.

수학적 집합처럼 합집합, 교집합, 차집합(addAll, retainAll, removeAll) 과 같은 연산을 제공하지만 컬렉션 자체를 바꾸는것이 아닌 새로 할당된 컬렉션을 반환한다.


#### List
Collection을 기반으로 하여 원소간에 정해진 순서를 부여한 컬렉션.

원소간의 순서가 중요할 경우 사용한다.

#### Set
중복원소를 허용하지 않는 컬렉션

수학에서 사용하는 집합의 개념과 비슷하지만, Set에 원소를 추가하면 변경된 컬렉션을 반환하는 것이 아닌 컬렉션 자체가 바뀐다는 점이 다르다.

Set은 어떤 원소가 몇번 나타나는지를 지원하지 않고, 원소사이에 순서도 없다.

원소가 존재하는지만이 중요한 경우 유용하게 사용할 수 있다.

#### SortedSet
중복 원소를 허용하지 않으면서도 순서를 유지하는 인터페이스이다.

컬렉션에 추가된 순서나 인덱스번호에 따라 순서가 유지되는 List와는 달리 SortedSet은 Compartaor에 의해서 순서를 정한다.
</br>명시적인 순서를 제공하지 않는 경우에는 `자연순서`가 사용된다.

```java
public Collection<String> getAlphabetCalAuthors() {
	Comparator<Author> sorter = new Comparator<Author> () {
		public int compare(Author o1, Author o2){
			if(o1.getLastName().equals(o2.getLastName())) {
				return o1.getFirstName().compareTo(o2.getFirstName());
			}   
			
			return o1.getLastName().compareTo(o2.getLastName());
        }
    }
};

SortedSet<Author> results = new TreeSet<Author>(sorter);

for(Book each: getBooks()) {
	results.add(each.getAuthor());
}

return results;
```

#### Map
Map은  List처럼 키를 사용해서 원소를 저장하지만 List는 정수만을 키로 사용할 수 있는 반면 Map은 임의의 객체를 키로 사용할 수 있다.
</br>Map의 키는 Set의 원소와 마찬가지로 중복사용될 수 없지만, 원소데이터는 중복 사용이 가능하다.
</br>Map의 원소 순서는 보장되지 않는다.

Map은 다른 컬렉션 인터페이스의 특징을 사용하지 않으므로 다른 컬렉션 인터페이스를 사용하지 않는다.

Map은 내부적으로 key에 대한 컬렉션, value에 대한 컬렉션 2개의 컬렉션을 유지한다.

Map에 대해서는 단순히 순차열람자를 사용할 수 없다. 키에 대한건지, 값에 대한건지, 키-값 쌍에 대한 건지 모호하기 때문이다.

Map은 외재상태와 변수상태와 같은 구현패턴에 유용하게 사용될 수 있다.

외재상태는 어떤 객체에 대한 정보를 객체 외부에 저장하는 것.
</br>키를 객체로, 데이터를 상태로 한 Map을 사용하면 외재 상태를 간단하게 구현할 수 있다.

변수상태는 같은 클래스에 속한 각 인스턴스마다 다른 종류의 데이터 필드를 갖는 것
</br>키를 문자열로, 데이터를 해당 필드에 대한 값으로 사용하는 맵을 사용하여 변수상태를 구현할 수 있다.

## 4. 구현
컬렉션의 구현 클래스를 선택하는 것은 성능과 관련이 있다.

어떤 구현을 사용할지 결정하는 주요 요소는 성능이다.

#### Collection
Collection인터페이스에 대한 기본 구현클래스는 ArrayList이다.

ArrayList는 컬렉션의 크기에 비례하여 contains(Object)와 이 메서드를 사용하는 다른 메서드에서의 연산시간이 커진다.

contains와 이 메서드를 사용하는 다른 메서드들이 성능을 제약하는데, 중복 원소를 제거해도 상관 없다면 HashSet의 사용을 고려하자.

#### List
흔히 사용되는 List의 구현은 ArrayList와 LinkedList이다.

ArrayList는 원소접근이 빠르고 원소 추가 및 제거가 느린 반면,
</br>LinkedList는 원소 접근이 느리지만 원소 추가와 제거가 빠르다.

원소의 추가, 제거가 많다면 ArrayList대신 LinkedList를 고려하라.

#### Set
많이 사용되는 Set의 구현은 HashSet, LinkedHashSet, TreeSet(SortedSet) 세 가지가 있다.

HashSet은 가장 빠르지만 순서를 보장하지 않는다.
</br>LinkedHashSet은 원소간 순서를 삽입된 순서로 보장하지만 원소 추가-삭제시 30%정도 시간이 더 걸린다.
</br>TreeSet은 Compartor에 따라 원소를 정렬하지만 원소 추가-삭제 시간이 logN(N=컬렉션의 크기)에 비례해서 커진다.


#### Map
Map의 구현체 몇개를 보면 Set과 비슷한데..

HashMap은 가장 빠르고 단순하다.
</br>LinkedHashMap은 컬렉션에 추가된 원소 간 순서를 보장한다.
</br>TreeMap(SortedMap)은 키의 순서에 따라 순차 열람이 가능하지만 원소 추가-제거 시간이 logN(N=컬렉션의 크기)에 비례한다.


## 5. Collections
Collections는 컬렉션 인터페이스에 넣기 적절치않은 기능들을 모아 놓은 유틸리티 클래스이다.
</br>Collections에서 제공하는 기능을 알아본다.

#### 검색
indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례한다.

만약 원소들이 정렬되어 있다면 이진검색을 사용해서 log2N에 비례하는 시간에 검색할 수 있다.
`Collections.binarySearch(list, element)` 로 좀더 효율적으로 리스트 원소에 대한 인덱스를 구할 수 있다.

만약 리스트가 정렬되어 있지 않다면 결과는 예측할 수 없다.

이진검색은 ArrayList와 같이 상수시간에 임의의 접근이 가능한 리스트에 대해서만 향상된 성능을 제공한다. (LinkedList에서는 성능 차이 없음)

#### 정렬
Collections는 리스트 원소 간의 순서를 바꾸는 연산을 제공한다.

- reverse(list) : 리스트에 속해 있는 모든 원소간의 순서를 거꾸로 바꿈
- shuffle(list) : 순서를 임의로 바꿈
- sort(list), sort(list, comparator) : 오름차순으로 원소 정렬

정렬을 수행할 경우 컬렉션의 원소들이 배열로 복사되어 졍렬된 후 다시 본래 컬렉션으로 복사된다.

#### 수정 불가능한 컬렉션
신뢰할 수 없는 코드에 컬렉션을 전달할 때 Collections로 래핑하여 클라이언트가 컬렉션을 수정하려 들 경우 예외를 발생시키도록 할 수 있따.

```java
@Test(expected=UnsupportedOperationException.class)
public void unmodifiableCollectionsThrowExceptions() {
	List<String> list = new ArrayList<String>();
	list.add("a");
	
	Collection<String> unmodifiable = Collections.unmodifiableCollection(list);
	
	Iterator<String> all = unmodifiable.iterator();
	all.next();
	all.remove();
}
```

#### 단일 원소 컬렉션
하나의 원소를 전달해야하지만 컬렉션 인터페이스를 사용해야하는 경우 Set, List, Map을 반환하는 메서드를 사용할 수 있다.

- Collections.singleton
- Collections.singletonList
- Collections.singletonMap

이때 반환되는 컬렉션은 모두 수정할 수 없다.

#### 무원소컬렉션
컬렉션 인터페이스를 사용해야하지만 전달할 원소가 없는 경우에는 수정할 수 없는 무원소 컬렉션을 생성해서 사용할 수 있다.

- 각 컬렉션 인터페이스별로 존재하는 Collections.empty~ 시리즈 사용

## 6. 컬렉션 확장
컬렉션 클래스를 상속받아 확장하는 경우가 있다.

ex) 책 리스트를 가지고 있는 Library class `class Library extends ArrayList {...}`

ArrayList를 상속했으므로 add(), remove() 등 컬렉션 관련 연산들이 지원된다.

하지만 컬렉션과 같은 행위를 지원하기 위해서 컬렉션을 확장하는 것은 몇가지 문제가 있는데,

#### 1. 컬렉션에서 제공하는 많은 연산들이 클라이언트 측에 부적절할 수 있다.
예로 클라이언트는 Library에 대해 clear()나 toArray()와 같은 연산을 수행하면 안된다. (Library라는 성질에 어긋나는 연산들)

이런 문제가 없더라도 여러 메타포가 섞여서 코드의 복잡도가 높아진다. (컬렉션의 메타포 외의 메타포들)

최악의 경우 지원할 필요가 없는 연산을 모두 새로 구현하고 UnSupportedOperationException을 발생시켜야한다.

#### 2. 소중한 자원인 상속을 망쳐놓을 수 있다.
몇 줄 안되는 유용한 구현을 재사용하기 위해 더 유용하게 사용할 수도 있는 상속을 사용해버릴 수도 있다. (한번뿐인 상속을 컬렉션 기능 몇개 사용하자고 낭비하는..)

이런 경우 상속을 사용하는 것보다 위임을 사용하는 편이 낫다
```java
class Library {
	Collection<Book> books = new ArrayList<Book>();
    ...
}
```

이렇게되면 유용한 연산에 한해 의미있는 이름을 붙여서 재사용할 수 있다.

또한 필요한 경우 상속을 사용해서 다른 모델 클래스와 구현을 공유하는 것도 가능하다.

java.util에 포함될만한 범용 컬렉션 클래스를 구현하는 경우에만 컬렉션을 상속받게하라.



