## 52. 다중정의는 신중히 사용하라

다중정의(오버로딩)된 메서드는 **어떤 메서드를 호출할지가 컴파일타입에 정해진다**

컴파일 타임 기준으로 호출될 메서드가 정해지기 때문에 직관과 어긋난다.

**재정의한 메서드는 동적으로 선택되고 다중정의한 메서드는 정적으로 선택된다**

오버라이딩된 메서드는 가장 하위에서 정의된 메서드가 실행된다.

반면 오버로드된 메서드는 컴파일 타임에 실행될 메서드가 결정되기때문에 메서드를 오버로딩할때는 신중히 생각해야한다.

프로그래머가 보기에는 재정의 메서드의 동작방식이 정상처럼 보이고 다중정의 메서드는 예외적인 동작처럼 보일것이다. 이는 사용자에게 매우 헷갈릴 수 있는 여지를 준다.

API 사용자가 어떤 다중정의 메서드가 실행될지 모른다면 프로그램이 오동작하기 쉽다. 또한 오동작되었을 때 문제를 찾기도 어렵다. 따라서 **다중정의가 혼동을 일으키는 상황을 피해야 한다**

**안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자**

가변인수를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다.

다중정의 대신 메서드 이름을 다르게 짓는 쉬운 방법도 열려있다.

**생성자의 경우**

생성자는 이름을 다르게 지을 수 없으므로 두번째 생성자부터는 무조건 다중정의가 된다.

하지만 정적팩터리라는 대안을 사용할 수 있따.

또한 생성자는 재정의가 불가능하므로 다중정의와 혼용될 가능성이 없다

매개변수 중 하나 이상이 근본적으로 다르다면(두 타입이 서로 형변환할 수 없다면) 헷갈릴 일이 없다. 이 조건만 충족하면 어느 다중정의 메서드를 호출할지가 매개변수들의 런타임 타입만으로 결정된다. ⇒ 혼란이 사라지게 된다.

**오토박싱 도입으로 인해**

자바4까지는 모든 기본타입이 모든 참조타입과 근본적으로 달랐으나,
자바5에서 오토박싱의 도입으로 인해 그렇지 않게 되었다.

ex)

```java
public class SetList{
	public static void main(String[] args){
	Set<Integer> set = new TreeSet<>();
	List<Itneger>list = new ArrayList<>();

	for(int i = -3; i< 3; i++){
		set.add(i);
		list.add(i);
	}

	for(int i = 0; i<3; i++){
		set.remove(i);
		list.remove(i);
	}
	
	sout(set + " " + list);
	}
}
```

위 코드는 -3 ~ 2까지의 정수를 각각 추가하고 remove메서드를 세번 호출한다.

예상되는 결과값은 “[-3, -2, -1] [-3, -2, -1]”이지만

실제로는 집합에선 음이 아닌 값을, 리스트에선 홀수를 제거하고 “[-3, -2, -1] [-2, 0, 2]”를 출력한다

set.remove(i)의 시그니처는 remove(Object)이다. 따라서 0, 1, 2 가 제거된다.

list.remove(i)의 시그니처는 remove(int index)이다. 따라서 지정된 위치의 원소가 제거되고 차례로 0, 1, 2번째 원소가 제거된 것이다.

이 문제는 list.remove의 인수에 Integer로 형변환하여 올바른 다중정의 메서드를 선택하게 하면 해결된다.

```java
for(int i = 0; i<3; i++){
		set.remove(i);
		list.remove((Integer)i);
	}
```

혼란의 이유는 List<E>인터페이스가 remove(Object), remove(int)를 다중정의했기 때문이다.

자바 4이전까지는 Object와 int가 근본적으로 달랐으나 제네릭, 오토박싱의 등장으로 인해 두 매개변수 타입이 근본적으로 다르지 않게 되었다.

**람다, 메서드참조와 다중정의**

자바 8에 도입된 람다와 메서드참조도 다중정의 시 혼란을 키웠다

ex)

```java
// 1번
new Thread(System.out::println).start();

// 2번
ExecutorService exec = Executors.newCachedThreadPool();
exec.submit(System.out::println);
```

인수로 넘겨진 메서드참조가 같고 두 메서드 모두 Runnable을 받는 형제 메서드를 다중정의하고있다.

하지만 2번은 컴파일오류가 발생한다.

이유는 submit메서드중에는 Callable<T>를 받는 메서드도 있다.

println은 void를 반환하므로 반환값이 있는 Callable과 헷갈릴리 없다고 생각할 수도 있으나 **다중정의해소(적절한 다중정의 메서드를 찾는 알고리즘**은 이렇게 동작하지 않는다.

만약 println이 다중정의 없이 단 하나만 존재했다면 submit메서드 호출도 제대로 컴파일됐을 것이다

지금은 참조된메서드(println)와 호출한 메서드(submit)양쪽 다 다중정의되어있어서 다중정의 해소 알고리즘이 기대처럼 동작하지 않는다.

System.out::println은 부정확한 메서드 참조이다.

암시적 타입 람다식이나 부정확한 메서드 참조같은 인수 표현식은 목표타입이 선택되기 전에는 그 의미가 정해지지 않기 때문에 적용성 테스트가 무시된다.

이것이 근본 원인이다.

핵심은,

다중정의된 메서드들이 함수형 인터페이스를 인수로 받을 때 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다.

따라서 **메서드를 다중정의할 때 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다**

이 말은 **서로 다른 함수형 인터페이스라도 근본적으로 다르지 않다는 뜻이다**

위 상황이 괜찮은 경우가 있는데

String의 contentEquals(StringBuffer)메서드는 자바 5부터

StringBuffer,StringBuilder, String, CharBuffer등의 타입을 위한 공통 인터페이스 CharSequence를 지원하기 위해 contentEquals(CharSequence)로 다중정의 되었다.

하지만 두 메서드는 같은 객체를 입력하면 같은 작업을 수행하므로 괜찮다.