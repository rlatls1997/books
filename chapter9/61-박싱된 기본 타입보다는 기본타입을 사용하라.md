## 61. 박싱된 기본 타입보다는 기본타입을 사용하라

오토박싱, 오토언박싱덕에 기본타입과 래퍼타입을 구분하지 않고 사용할 수 있지만 차이가 존재한다.

**기본타입과 래퍼타입의 차이**

- 기본타입은 값만 가지고 있으나 래퍼타입은 값과 식별성을 갖는다. 값이 같아도 서로 다르다고 식별될 수 있다.
- 기본타입은 값이 언제나 유효하지만 래퍼타입은 유효하지않은 값(null)을 가질 수 있다
- 기본타입은 래퍼타입보다 시간, 메모리 사용면에서 더 효율적이다.

Integer를 오름차순 정렬하는 비교자를 예로 들어보자

```java
Comparator<Integer> naturalOrder = 
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

문제가 없어보이지만 다음의 경우는 문제가 있다

```java
naturalOrder.compare(new Integer(42), new Integer(42));
```

==검사에서 두 객체 참조의 식별성을 검사히기 때문에 false를 반환하게 된다.

**박싱된 기본타입에 ==연산자를 사용하면 오류가 일어난다**

다음처럼 수정하여 식별성 검사를 피할 수 있다

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) ->{
	int i = iBoxed;
	int j = jBoxed;
	return (i < j) ? -1 : (i == j ? 0 : 1);
}
```

버그가 있는 프로그램을 하나 더 보자

ex) NPE가 발생하는 프로그램

```java
public class Test{
	static Integer i;
	public static void main(String[] args){
		if(i== 42){
			...
		)
	}
}
```

이 코드는 i == 42에서 NPE가 발생한다.

i는 래퍼타입은 Integer이며 초깃값이 null값이다.

i == 42는 Integer와 int를 비교하는 것이다.

거의 모든 경우에서 **기본타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다**

여기서 null참조를 언박싱하면 NPE가 발생하는 것이다.

마지막으로 박싱과 언박싱은 성능에 영향을 끼치므로 피하는 것이 좋다.

**래퍼타입을 사용해야하는 경우**

- 컬렉션의 원소, 키, 값으로 사용될 경우.(타입매개변수로 기본타입은 지원되지 않는다)
- 리플렉션을 통해 메서드를 호출할 경우