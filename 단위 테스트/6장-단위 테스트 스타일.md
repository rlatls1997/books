# 6장 단위테스트 스타일

단위 테스트 스타일에 대한 스타일 학습

## 6.1 단위 테스트의 세 가지 스타일

- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

### 1. 출력 기반 테스트 정의

테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검사는 방식의 테스트.<br>
출력 기반 테스트는 전역상태나 내부상태를 변경하지 않는 코드에만 적용된다.(부작용이 없다)

따라서 반환값만 검증하면 된다.

### 2. 상태 기반 스타일 정의

작업이 완료된 후 시스템의 상태를 확인하는 테스트.<br>
SUT, 협력자 클래스, 데이터베이스, 파일시스템 등 프로세스 외부 의존성의 상태를 검증한다.

### 3. 통신 기반 스타일 정의

목을 사용하여 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

SUT의 협력자를 Mock으로 대체하고 Mock으로 대체된 협력자가 올바르게 호출되는지 검증한다.

ex)

```text
public void sending_a_greetings_email() {
    var emailGatewayMock = new Mock<IEmailGateway>();
    var sut = new Controller(emailGatewaymock.Object);
    
    sut.GreetUser("user@email.com");
    
    emailGatewayMock.Verify(
        x => x.SendGreetingsEmail("user@email.com"),
        Times.Once);
}
```

## 6.2 단위 테스트 스타일 비교

좋은 단위 테스트를 판별하는 4대 요소로 위 3가지의 단위 테스트 스타일을 비교해본다.

- 회귀방지 : 버그가 있는 코드를 테스트에서 잘 실패하는지에 대한 지표. 버그를 잘 나타낼수록 회귀(버그)를 잘 방지할 수 있다.
- 리팩터링 내성 : 버그가 없는 코드를 테스트에 실패시키지 않고 리팩터링할 수 있는지에 대한 지표.
- 빠른 피드백 : 오래걸리는 테스트는 자주 실행하지 못하므로..
- 유지 보수성 : 테스트가 얼마나 이해하기 어려운지, 테스트를 위한 의존성을 유지하느라 테스트를 실행하기 어려운지에 대한 지표

### 1. 회귀방지, 피드백 속도 지표로 스타일 비교하기

회귀 방지 지표는

- 테스트 중 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성
  세 가지 특성으로 결정된다.

테스트는 테스트 스타일에 상관없이 많이 작성되거나 적게 작성될 수 있으므로 회귀방지 지표는 스타일에 따라서 갈리지 않는다.<br>

테스트 피드백 속도 또한 스타일과는 관계가 없다.(목은 런타임에 약간의 지연이 생기지만 큰 차이 없다.)

### 2. 리팩터링 내성 지표로 스타일 비교하기

거짓 양성 : 코드에 버그가 없음에도 테스트에 실패하는 케이스

**출력 기반 테스트**<br>
출력기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다. (입력에 따른 출력만 검사하면 되므로..)

**상태 기반 테스트**<br>
상태 기반 테스트는 거짓 양성이 되기 쉽다.

상태 기반 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 동작한다.
이렇게 결합도가 클수록 구현 세부 사항에 테스트가 얽매일 가능성이 커진다.

**통신 기반 테스트**<br>
허위 경보에 가장 취약하다.

테스트 대역으로 상호작용을 확인하는 부분은 깨지기 쉽기 때문이다.
(이는 대부분 스텁(내부로 들어오는 상호작용의 모방)과 상호작용하는 경우이다.)

캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.

### 3. 유지 보수성 지표로 스타일 비교하기
테스트 스타일과 밀접한 관련이 있으나 완화할 수 있는 방법이 많지 않다.
유지보수성은 다음을 확인한다.
- 테스트를 이해하기가 얼마나 어려운가?
- 테스트를 실행하기가 얼마나 어려운가?(테스트에 직접적으로 관련있는 외부의존성 개수, 유지보수의 필요성)

테스트가 너무 크면 필요할 때 파악하기 어렵고 변경하기도 어려워 유지보수가 힘들다.<br>
프로세스 외부 의존성(데이터베이스 등)과 직접 작동하는 테스트 또한 존재할경우 별도 운영이 필요하므로 유지보수가 어렵다.

**출력 기반 테스트**<br>
출력 기반 테스트는 대부분 짧고 간결하다.<br>
전역 상태나 내부 상태를 변경하지도 않고 프로세스 외부 의존성을 다루지도 않는다.

따라서 유지보수하기 용이하다.

**상태 기반 테스트**<br>
유지보수가 쉽지 않다.
출력 검증보다 상태 검증이 더 많은 경우가 있기 때문이다.

ex) 상태 검증이 많은 테스트
```text
public void Adding_a_comment_to_an_article() {
    var sut = new Article();
    var text = "comment text";
    var author = "john doe";
    var now = new DateTime(2019, 4, 1);
    
    sut.AddComment(text, author, now);
    
    // 많은 상태 검증
    Assert.Equal(1, sut.Comments.Count);
    Assert.Equal(text, sut.Comments[0].Text);
    Assert.Equal(author, sut.Comments[0].Author);
    Assert.Equal(now, sut.Comments[0].DateCreated); 
}
```

코드를 숨기고 테스트를 단축하는 헬퍼메스드로 문제를 완화할 수 있으나,<br>
이러한 메서드를 작성하고 유지하는데는 추가적인 노력이 필요하고 재사용하지 않는다면 명분이 부족하다.

상태 기반 테스트를 단축하는 다른 방법으로 객체 인스턴스의 값을 비교하는 방법이 있다.
ex) 객체끼리의 값 비교
```text

public void Adding_a_comment_to_an_article() {
    var sut = new Article();
    var comment = new Comment( "comment text",
        "john doe",
        new DateTime(2019, 4, 1));
    
    sut.AddComment(comment.Text, comment.Author, comment.DateCreated);
    
    // 객체 값 비교
    sut.Comments.Should().BeEquivalentTo(comment); 
}
```
이는 클래스가 갑에 해당하고 값 객체로 변환할 수 있을때만 효과적이다.

헬퍼메서드를 사용하는 방법, 값 객체로 비교하는 방법은 가끔만 사용할 수 있고,<br>
위 방법을 적용하더라도 출력 기반 테스트보다는 유지보수성이 떨어진다.

**통신 기반 테스트**<br>
유지보수성 측면에서 출력 기반 테스트와 상태 기반 테스트보다 점수가 낮다.

테스트 대역과 상호 작용 검증을 해야하며 이는 코드공간을 많이 차지한다.

### 4. 스타일 비교하기: 결론
|                        | 출력 기반 스타일 | 상태 기반 스타일 | 통신 기반 스타일 |
|------------------------|-----------|-----------|-----------|
| 리팩터링 내성을 지키기 위해 필요한 노력 | 낮음        | 중간        | 중간        |
| 유자비                    | 낮음        | 중간        | 높음        |

출력기반테스트는 구현 세부사항과 거의 결합되지 않고 간결하고 외부 의존성이 없다.<br>
따라서 유지보수하기 쉽다.

상태기반테스트는 구현 세부 사항에 결합할 가능성이 높고 크기도 커서 유지비가 많이 든다.

결론은 출력 기반 테스트를 선호하는 것이지만 현실적으로 한계가 있다.<br>
함수형으로 작성된 코드에만 적용할 수 있기 때문이다.

## 6.3 함수형 아키텍처 이해
함수형 프로그래밍과 함수형 아키텍쳐가 무엇인지 알아본다.<br>
함수형 아키텍처와 육각형 아키텍처가 어떤 관련이 있는지 살펴본다.

### 1. 함수형 프로그래밍이란?
함수형 프로그래밍은 수학적 함수(순수 함수)를 사용한 프로그래밍.<br>
순수함수란 숨은 입출력이 없는 함수를 말한다.

순수함수의 모든 입출력은 메서드 이름, 인수, 반환타입으로 구성된 메서드 시그니처에 명시해야한다.

순수함수는 몇번 호출되든 주어진 입력에 대해 항상 동일한 출력을 반환한다.

**숨은 입출력**<br>
순수함수는 유지보수성이 뛰어나고 거짓 양성 빈도가 낮다.<br>
반면 숨은 입출력이 있는 경우 코드를 테스트하기 어렵고 가독성도 떨어진다.

- 부작용 : 메서드 시그니처에 표시되지 않은 출력이다. 클래스 인스턴스의 상태를 변형하고 파일을 업데이트 하는 등의 부작용을 발생시킨다.
- 예외 : 예외는 메서드 시그니처에 해당하지 않는 흐름을 만들어낸다.
- 내외부 상태에 대한 참조 : DateTime.Now, 데이터베이스 질의 결과, 비공개 변경 가능 필드 참조 등은 메서드 시그니처에 없는 실행흐름에 대한 입력이고 숨어있다.

순수함수인지 판단하는 방법은 해당 메서드에 대한 호출을 반환값으로 대체할 수 있는지 확인하는 것.
이를 참조투명성이라고 한다.
ex) 참조투명성이 있는 경우
```text
public int Increment(int x) {
    return x + 1;
}

int y = Increment(4);
int y = 5; // Increment(4)를 5로 바꿀 수 있으므로 순수하다.
```
ex) 참조투명성이 없는 경우
```text
int x = 0;
public int Increment() {
    x++; // 반환값 외의 숨은 출력(x의 변경, 부작용)
    return x;
}

int y = Increment(); // y를 Increment()의 반환값으로 대체할 수 없음
```

### 2. 함수형 아키텍처란?
부작용이 없는 애플리케이션은 만들 수 없다.

함수형 프로그래밍의 목표는 부작용을 일으키는 코드와 비즈니스 로직을 처리하는 코드를 분리하는 것이다.

함수형 아키텍처는 부작용을 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 바작용과 분리한다.<br>
함수형 아키텍처는 부작용을 다루는 코드를 최소화하면서 순수함수 + 불변 방식으로 작성한 코드의 양을 극대화한다.

코드 유형을 다음 두 가지로 분류하여 비즈니스 로직과 부작용을 분리할 수 있다
- 결정을 내리는 코드 : 부작용이 없으므로 순수함수로 작성할 수 있음.
- 해당 결정에 따라 작용하는 코드 : 순수함수에 의해 이뤄진 결정을 데이터베이스 등에 반영하는 코드

결정을 내리는 코드를 `함수형 코어`라고도 한다.
결정에 따라 작용하는 코드를 `가변 셀`이라고 한다.

함수형 코어와 가변셀은 다음 방식으로 협력한다. (p.201 그림 6.9참고)
- 가변셀은 모든 입력을 수집한다. (들어가야하는 입력값 생성)
- 함수형 코어는 결정을 생성한다. (입력에 대한 출력 결과를 생성)
- 셀은 결정을 부작용으로 변환한다.(결과를 데이터베이스 등에 반영하는 작업 등)

### 3. 함수형 아키텍처와 육각형 아키텍처 비교
함수형 아키텍처는 부작용이 있는 로직과 비즈니스 로직을 분리한다.
육각형 아키텍처는 도메인계층(비즈니스 로직 담당)과 애플리케이션 서비스 계층(DBMS, SMTP서비스 등 외부 애플리케이션과의 통신 담당)을 구별한다.

**유샤점**
- 결정과 실행을 분리한다.
- 의존성간의 흐름이 단방향이다.

**차이점**
- 부작용 처리
  - 함수형 아키텍처는 모든 부작용을 불변 코어에서 비즈니스 연산의 가장자리(가변 셸)로 밀어낸다.
  - 육각형 아키텍쳐는 도메인 계층에 한정해서 부작용이 없다. 모든 수정사항은 도메인 계층 내에 있으며 벗어나서는 안된다.


## 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환
다음 두 단꼐를 거쳐 함수형 아키텍처로 리팩터링 하는 방법을 알아본다.
- 프로세스 외부 의존성에서 목으로 변경
- 목에서 함수형 아키텍처로 변경

p.204~ 예제코드 참고


### 1. 감사 시스템 소개
샘플코드는<br>
- 조직의 모든 방문자를 추척하는 감사 시스템이다.
- 텍스트 파일을 저장소로 사용한다
- 가장 최근 파일의 마지막 줄에 방문자의 이름과 방문 시간을 추가한다.
- 파일당 최대 항목수에 도달하면 새 파일을 만들어 작성한다.

### 2. 테스트를 파일 시스템에서 분리하기 위한 목 사용
샘플코드는 파일 시스템과 밀접하게 연결되어 있어서 테스트하기 어렵다. (테스트전에 파일을 정확한 위치에 배치하고 테스트가 끝나면 해당 파일을 읽고 확인 후 내용을 삭제해야함(항상성을 위해서))<br>
따라서 파일시스템 목으로 처리해 해결한다.

파일시스템을 목으로 처리하기 위해서 파일처리를 탐당하는 로직을 인터페이스로 분리하고 샘플코드에 주입하여 사용한다.<br>
파일시스템을 분리하여 감사시스템 코드에서는 공유의존성이 사라지고 테스트를 독립적으로 실행할 수 있다.<br>
-> 감사시스템의 테스트에서 더이상 파일시스템에 접근하지 않아도 되므로 테스트 피드백이 개선된다.

### 3. 함수형 아키텍처로 리팩터링하기
부작용을 인터페이스 뒤로 숨기고 해당 인터페이스를 주입하는 대신에 부작용을 클래스 외부로 완전히 이동할 수 있다.
감사시스템에서는 파일에 어떤 작업을 수행할지에 대한 결정만 내린다. (파일업데이트에 필요한 정보만 반환한다.)

파일시스템에 업데이트하는 작업 담당하는 새로운 클래스를 만들어서 부작용을 분리한다.

파일에 어떤 작업을 수행할지에 대한 비즈니스 연산은 감사시스템 클래스에서,<br>
파일과 직접 상호작용하는 부작용이 있는 작업은 새로운 클래스에서 담당하여 부작용을 분리한다.

결과적으로 감사시스템을 담당하는 클래스는 함수형 코어(순수함수)가 되어 목 없이 출력 기반 스타일의 테스트를 수행할 수 있다.

### 4. 예상되는 추가 개발
예제 코드에 개발 사항이 추가될 경우에도 함수형 아키텍처를 유지하는 내용. 특별한 내용 없음.

## 6.5 함수형 아키텍처의 단점 이해하기
항상 함수형 아키텍처를 이룰 수 있는 것으 ㄴ아니다.<br>
함수형 아키텍처라고 해도 코드베이스가 커지고 성능에 영향을 주면 유지보수성의 이점이 상쇄될 수 있다.

함수형 아키텍처와 관련된 비용과 장단점을 알아보자.

### 1. 함수형 아키텍처의 적용 가능성
함수형 코어(순수함수)에 숨은입력(데이터베이스에서 값을 읽어오는 등)이 생겼을 경우 더이상 순수함수가 아니며 함수형 아키텍처를 따르지 않는다.

예로 감사시스템 로직에서 데이터베이스에 저장된 방문자 접근 레벨을 확인한다고 해보자.<br>
함수형코어에 해당하는 감사시스템에서 숨은입력이 추가되었으므로 위 로직이 추가된 메서드는 순수함수가 아니며 더이상 출력 기반 스타일 테스트를 적용할 수 없다.

이에 대한 해결책으로는
- 함수형 코어에 접근하기 전 가변셸(부작용이 발생할 수 있는 영역)에서 방문자 접근레벨을 읽어온다.
- 함수형 코어에서 숨은 입력이 필요한지 판별하는 새로운 메서드를 두고 해당 경우에만 가변셸에서 방문자 접근레벨을 읽어온다.

첫번째 방법은 접근레벨이 필요없는 경우에도 무조건 데이터베이스에 접근하므로 성능이 저하되지만,<br>
비즈니스로직과 외부 시스템과의 통신을 완전히 분리할 수 있다.

두번째 방법은 성능향상을 위해 분리를 조금 완화했다.<br>
데이터베이스를 호출할지에 대한 결정이 감사시스템 코드가 아닌 애플리케이션 서비스로 넘어가게 된다.

### 2. 성능 단점
함수형 아키텍처를 따르다보면 성능문제가 생길 수 있다.
시스템 전체적으로 프로세스 외부 의존성을 더 많이 호출하게 된다.<br>
(다 뭉쳐있을때는 진짜 필요할때만 외부 의존성에 접근하는데 함수형 코어와 가변셸을 분리하고 나면 케이스를 구분하기 어려워서 그런듯)

성능 영향이 눈에 띄지 않는 수준이라면 함수형 아키텍처를 사용해서 유지보수성을 향상시키자.

### 3. 코드베이스 크기 증가
함수형 아키텍처를 통해 코드복잡도를 낮추고 유지보수성을 향상시킬 수 있다. 하지만 초기에 코딩이 더 필요하다
복잡도가 그리 높지않다면 프로젝트 초기부터 함수형 아키텍처를 사용하는 것은 별 의미 없다.

함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지 말라.<br>
대부분의 프로젝트에서 모든 도메인 모델을 불변으로 할 수 없기 때문에 출력 기반 테스트에만 의존할 수 없다.<br>
