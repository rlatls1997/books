# 7. 가치 있는 단위 테스트를 위한 리팩터링

좋은 단위 테스트 스위트의 속성
- 개발주기에 통합되어 있고
- 코드베이스 중 가장 중요한 부분만을 대상으로 하고
- 최소한의 유지비로 최대의 가치를 이끌어내기
  - 가치있는 테스트를 식별해야함
  - 가치있는 테스트를 작성해야함

단위테스트와 기반코드는 서로 얽혀있기 때문에 코드베이스에 노력을 기울이지 않고서는 가치있는 테스트를 만들 수 없다.
가치있는 테스트를 작성하는 방법과 관련해 실용적인 지침을 알아본다.

## 7.1. 리팩터링할 코드 식별하기
코드를 네 가지 유형으로 분류할 수 있다.

### 1. 코드의 네 가지 유형
코드는 다음을 기준으로 2차원으로 분류할 수 있다
- 복잡도 또는 도메인 유의성
- 협력자 수

**복잡도**<br>
코드 내 분기의 수

**도메인 유의성**<br>
코드가 프로젝트의 문제 도메인에 얼마나 의미있는지를 나타냄.<br>
도메인 계층의 모든 코드는 도메인 유의성이 높은 반면 유틸리티 코드는 그런 연관성이 없다.

**협력자 수**<br>
가변의존성 또는 프로세스 외부 의존성.<br>
유지보수성지표는 테스트크기에 따라 갈리는데 협력자가 많으면 테스트도 커져서 테스트 비용이 많이든다.

협력자의 유형도 중요한데,<br>
도메인 모델이라면 프로세스 외부 협력자를 사용하면 안된다.<br>
테스트에서 목 체계가 복잡하기 때문에 유지비가 더 들기 때문이다.<br>
프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는것이 좋다.

위 기준으로 코드를 네 가지 유형으로 나눌 수 있다.
![unit-testing-20.jpg](https://github.com/rlatls1997/books/assets/62635664/fd8bdf54-1bda-4116-94b5-b3b9bab4314c)

### 코드의 4가지 분류
- **도메인 모델과 알고리즘**<br>
보통 복잡한 코드는 도메인 모델이다.

이런 코드는 협력자가 거의 없어서 테스트 유지비용이 낮고<br>
코드가 복잡하거나 중요한 로직을 수행해서 테스트의 회귀 방지가 향상되기때문에<br>
이러한 코드를 대상으로한 테스트는 가치있고 비용이 저렴하다.

- **간단한 코드**<br>
매개변수가 없는 생성자같은 간단한 코드.<br>
테스트의 가치가 없기 때문에 테스트할 필요가 없다.


- **컨트롤러**<br>
도메인클래스와 외부 애플리케이션같은 다른 구성 요소의 작업을 조정하는 코드.<br>
복잡하거나 비즈니스적으로 중요하지는 않지만 포괄적인 통합테스트의 일부로써 테스트할만하다?


- **지나치게 복잡한 코드**<br>
ex) 복잡한 작업을 어디에도 위임하지 않고 모든 로직을 처리하는 컨트롤러

복잡하고 협력자도 많아서 단위테스트가 어려운 코드지만,<br>
테스트커버리지 없이 내버려두는 것은 위험하다.

지나치게 복잡한 코드를 알고리즘 + 컨트롤러로 나누는 것이 일반적이다.

복잡한코드를 제거하는데에 도움되는 기법이 있다.

### 2. 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
헙블객체 패턴을 사용하여 지나치게 복잡한 코드를 쪼갤 수 있다.

지나치게 복잡한 코드는 비동기, 멀티스레드 실행, 사용자 인터페이스, 프로세스 외부 의존성과의 통신 등 테스트하기 어려운 의존성과 복잡한 로직이 얽혀있는데,<br>
`테스트하기 어려운 의존성`과 `복잡한 로직`을 분리하고 이를 `험블객체`로 묶어서 `지나치게복잡한코드`를 쪼갤 수 있다.

육각형 아키텍처, 함수형 아키텍처도 이 패턴을 구현한다.<br>
육각형 아키텍처는 비즈니스 로직과 프로세스 외부 의존성과의 통신을 분리하고,<br>
함수형 아키텍처는 모든 협력자와의 커뮤니테이션에서 비즈니스 로직을 분리한다.<br>
이런 면에서 두 아키텍쳐도 험블객체패턴과 유사하다고 볼 수 있다.


험블객체패턴을 단일책임원칙에서도 바라볼 수 있다.<br>
비즈니스 로직과 오케스트레이션하는 역할을 분리하는 것을 생각해볼 수 있다.<br>
ex) 컨트롤러는 많은 협력자만 가지고 이를 조화시키는 책임, 도메인 계층 및 알고리즘은 각 협력자들의 책임


예로 MVC, MVP패턴도 생각해볼 수 있는데,<br>
위 패턴에서의 Presenter와 Controller를 모댈과 뷰 사이의 조정을 분리하기 위한 험블객체로 생각할 수 있다.


비즈니스 로직과 오케스트레이션을 분리해야하는 이유는
- 테스트 용이성이 좋아진다.
- 코드 복잡도를 해결할 수 있다.

## 7.2 가치 있는 단위 테스트를 위한 리팩터링하기
지나치게 복잡한 코드를 알고리즘과 컨트롤러로 나누는 종합 예제를 살펴본다.

### 1. 고객 관리 시스템 소개
예제는 고객관리시스템에서 사용자가 이메일을 변경하는 케이스이다.<br>

사용자가 이메일을 변경(changeEmail)하면
- 이메일이 회사 도메인에 속한 경우 직원으로, 아닐경우 고객으로 표시
- 사용자 유형이 직원에서 고객으로, 고객에서 직원으로 변경되면 직원 수 업데이트하기
- 이메일이 변경되면 메시지버스를 통해 외부 시스템에 알리기

예제는 도메인 유의성이 높은 코드임에도 암시적인 프로세스 외부 협력자(Database, MessageBus)를 포함한다.<br>
도메인클래스가 데이터베이스를 검색하고 다시 저장하는 방식을 활성 레코드(Active Record) 패턴이라고 하는데,<br>
`비즈니스로직`과 `프로세스 외부 의존성`과 통신에 분리가 없기 때문에 코드베이스가 커지면 확장하지 못하는 경우가 많다.

- **1단계 : 암시적 의존성을 명시적으로 만들기**<br>
테스트용이성을 개선하기 위해 암시적의존성을 명시적으로 만들 수 있다.

database, messageBus에 대한 인터페이스를 두고 이 인터페이스를 User에 주입하여 테스트에서 목으로 처리할 수 있따.<br>

- **2단계 : 애플리케이션 서비스 계층 도입**<br>
의존성을 명시적으로 만들었으나 여전히 복잡한 목 체계가 필요하고 테스트 유지비용이 든다.<br>
그리고 database같은 의존성에 목을 사용하면 테스트 취약성을 야기할 수 있다.

결론은 도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.

도메인 모델이 외부 시스템과 직접 통신하는 문제를 해결하려면 다른 클래스(험블 객체)로 책임을 옮겨야 한다.

- **3단계 : 애플리케이션 서비스 복잡도 낮추기**<br>
험블객체를 사용해서 외부 협력자와 도메인 모델을 분리해도 복잡한 로직이 남아있을 수 있다.

예제에서는 database에서 User 정보를 조회한 후 이를 인스턴스화하는 로직을 UserFactory으로 분리하여 험블객체(컨트롤러)의 복잡도를 낮췄다.<br>
(p.243 코드 참고)

- **4.단계 : 새 Compangy클래스 소개**<br>
p.244<br>
컨트롤러 코드를 보면 user인스턴스에서 회사의 인원수를 반환하는 부분이 있다.<br>
user의 책임이 어색한데 또 다른 도메인 클래스 Company를 두어 회사와 관련된 로직을 묶을 수 있다.

p.246의 코드를 보면 User클래스는 Company라는 협력자가 늘어서 테스트하기가 조금 까다로워졌으나 UserController의 복잡도는 줄어들었다.

## 7.3 최적의 단위 테스트 커버리지 분석
험블 객체 패턴으로 코드를 리팩터링하고 코드를 다시 네 가지 유형으로 나눠보자.<br>

비즈니스 로직과 오케스트레이션을 완전히 분리하면 어느 부분을 테스트 단위로 할지 쉽게 결정할 수 있다.

### 1. 도메인 계층과 유틸리티 코드 테스트하기
2사분면에 해당하는 `도메인 모델 및 알고리즘`은 단위테스트하기 매우좋다.<br>
복잡도나 도메인 유의성이 높아 회귀방지가 뛰어나고 협력자가 거의 없어서 유지비도 낮다.

p.249 참고

### 2. 나머지 세 사분면에 대한 코드 테스트하기
험블객체패턴으로 비즈니스 로직과 오케스트레이션을 분리하고 나면 1사분면에 해당하는 `지나치게 복잡한 코드`는 테스트 할것이 없다.

3사분면에 해당하는 `간단한 코드`는 너무 단순해서 테스트할 필요가 없다.

4사분면에 해당하는 `컨트롤러` 테스트는 다음장에서..

### 3. 전체 조건을 테스트해야 하는가?
예제코드에는 회사의 직원 수는 음수가 될 수 없다는 전제조건이 있다. 이런 조건도 테스트해야할까?<br>

-> 도메인 유의성이 있는 전제조건이라면 테스트하자. 도메인 유의성이 없다면 테스트하기엔 가치가 없다.


## 7.4 컨트롤러에서 조건부 로직 처리
조건부로직을 처리하면서 프로세스 외부 협력자 없이 도메인 계층을 유지보수하는 것은 까다롭고 절충이 있다.<br>
이러한 절충에 대해 알아보고 어떤 것을 선택할지 결정하는 방법을 알아보자.

비즈니스 로직과 오케스트레이션의 분리는 다음처럼 비즈니스 연산이 세 단계로 있을때 가장 효과적이다
![pasted image 0.png](https://github.com/rlatls1997/books/assets/62635664/8b091f04-9a50-402b-9e21-406b8ccf68c6)
- 저장소에서 데이터 검색
- 비즈니스 로직 실행
- 데이터를 다시 저장소에 저장

하지만 위와 같이 단순하지 않고<br> 
중간 결과에 따라서 프로세스 외부 의존성에서 추가 데이터를 조회한다던지,<br>
복잡한 경우가 많다.
![pasted image 0 (1).png](https://github.com/rlatls1997/books/assets/62635664/d95987ff-4436-4c77-a165-3c563c14044d)

이런 경우 다음 세 가지 방법이 있다
- 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어낸다.
비즈니스 로직의 중간결과에 상관없이 필요하거나 필요할 것 같은 외부 의존성호출을 미리 하는 방식이다.<br>
`읽기-결정-실행`의 구조를 유지하지만 필요없는 경우에도 프로세스 외부 의존성을 호출하므로 성능이 저하된다.

- 도메인 모델에 프로세스 외부 의존성 주입.
비즈니스 로직에서 해당 의존성을 호출할 시점을 직접 결정할 수 있게한다.(외부 의존성을 필요할때만 호출할 것이므로 효율적일 것이다)

- 의사 결정 프로세스 단계를 더 세분화하고 각 단계별로 컨트롤러를 실행하도록 한다.
의사 결정 프로세스 단계를 세분화(중간 결과를 더 많이 만들어내는..)하여 컨트롤러에서 각 중간결과에 따라 의존성을 호출할 시점을 결정하도록 처리


문제는 다음 세 가지 특성의 균형을 맞추는 것이다.
- 도메인 모델 테스트 유의성 : 도메인 클래스의 협력자 수와 유형에 따른 함수
- 컨트롤러 단순성 : 의사 결정(분기) 지점으로 판단.
- 성능 : 프로세스 외부 의존성에 대한 호출 수로 정의

![pasted image 0 (2).png](https://github.com/rlatls1997/books/assets/62635664/10665c75-3dd3-4492-989f-93572ab96911)
세 가지 특성에 따라 처음봤던 세 가지 방법의 특징을 살펴보면..
- 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어내는 방식
  - 컨트롤러를 단순하게 유지하고 프로세스 외부 의존성과 도메인 모델을 분리하여 테스트하기 좋다 
  - 필요하지 않은 외부 의존성에 대한 호출을 수행하므로 성능이 저하된다.
- 도메인 모델에 프로세스 외부 의존성 주입하는 방식
  - 필요한 호출만 하여 성능을 유지하며 컨트롤러의 단순함도 유지한다.
  - 도메인 모델에 협력자가 생기기때문에 테스트 유의성이 떨어진다.
- 의사 결정 프로세스 단계를 더 세분화하는 방식
  - 필요한 호출만 하여 성능을 유지하며 도메인 모델의 테스트 유의성에도 좋다.
  - 컨트롤러에 의사결정 세분화에 따른 분기가 생겨서 복잡해진다.


**결론**
- 성능은 매우 중요한 요소이므로 외부에 대한 읽기와 쓰기를 가장자리로 밀어내는 방식은 고려하지 않는다.
- 도메인 모델에 프로세스 외부 의존성을 주입하는 방식은 테스트와 유지보수하기가 훨씬 어려워진다. 
- 의사결정 프로세스 단계를 세분화하는 방식만이 남지만 컨트롤러가 복잡한 사분면에 가까워진다. 이런 문제를 완화할 수 있는 방법이 있다.

### 1. CanExecute/Execute 패턴 사용
컨트롤러 복잡도가 커지는것을 완화하기 위한 패턴.

예로 사용자의 이메일을 변경하는 메서드가 있다고 하자
```java
public class User {
    public string Email
    public bool IsEmailConfirmed
    ...
    public string ChangeEmail(string newEmail, Company company){
        if(IsEmailConfirmed)
            return "can't change a confirmed email";
    }
}
```

이메일은 사용자가 확인할 때까지만 변경할 수 있고,<br>
사용자가 확인한 후에 이메일을 변경하려고하면 오류메시지가 표시되어야한다

모든 의사 결정을 제거한 컨트롤러의 예시를 보자
ex) 모든 의사 결정을 제거한 컨트롤러
```java
public string ChangeEmail(int userId, string newEmail) {
    ...
    // 데이터 준비
    ...
    object[] companyData = _database.GetCompany();  // 이메일이 확인되었다면 필요없을 company 조회부분. 성능상 불이익
    Company company = CompanyFactory.Create(companyDate);
    
    string error = user.ChangeEmail(newEmail, company);
    ...
    // 결정에 따른 프로세스 외부 의존성 호출
    ...    
}
```
이메일을 변경할 수 없는 경우에도 데이터베이스에서 company인스턴스를 가져와야 하므로,<br>
컨트롤러는 의사결정을 하지 않지만 성능 저하를 감수해야한다.

의사결정을 Controller에서 해보자.
ex) 이메일 변경이 가능한지에 대한 여부를 컨트롤러에서 결정
```java
public string ChangeEmail(int userId, string newEmail) {
    ...
    // 데이터 준비
    ...
    if(user.IsEmailConfirmed)
        return "Can't change a confirmed email"; // 의사결정을 통해 이메일 변경이 불가능하다면 하위 로직 실행하지 않고 return 
    
    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyDate);
    
    string error = user.ChangeEmail(newEmail, company);
    ...
    // 결정에 따른 프로세스 외부 의존성 호출
    ...    
}
```
위와 같은 구현은 의사결정 여부에 따라 프로세스 외부 의존성을 호출하기 때문에 성능은 유지되지만,<br>
도메인 모델의 캡슐화가 떨어진다.(이메일 변경 메서드만 따로 호출하면 이메일 확인 여부 상관없이 변경이 가능하게 된다;)

이러한 파편화의 방지를 위해 이메일 변경의 전제조건에 해당하는 새 메서드(CanChangeEmail())를 만들 수 있다.
ex) CanExecute/Execute 패턴을 사용한 이메일 변경 (User클래스)
```java
public class User {
    public string Email
    public bool IsEmailConfirmed
    ...
    public string CanChangeEmail(){
        if(IsEmailConfirmed)
            return "can't change a confirmed email";
    }
    
    public string ChangeEmail(string newEmail, Company company){
        Precondition.Requires(CanchangeEmail() == null);
		
        ...
    }
}
```
CanExecute/Execute 패턴을 적용하면
- 컨트롤러는 이메일 변경 프로세스를 알 필요 없이(전제조건이 ChangeEmail()에 들어가있으므로) CanChangeEmail()메서드를 호출하여 연산을 수행할 수 있는지만 확인하면 된다.
- ChangeEmall()의 전제조건에 추가되어도 먼저 확인하지 않으면 이메일을 변경할 수 없도록 보장한다.


### 2. 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적
도메인 모델에 대한 변경사항을 추적하여 프로세스 외부 의존성 호출로 알려야 하는 경우가 있을 수 있다.

다음 예제에서는 이메일이 변경되지 않은 경우에도 메일을 발송한다.
ex) 이메일이 실제 변경되지 않았어도 메일을 발송하는 예(User, UserController)
```java
//User
public void changeEmail(String newEmail, Company company){
    Precondition.Requires(canChangeEmail() == null);
    
    if(Email == newEmail){ // 이메일이 변경되지 않을 수 있음
        return;
    }
    ...
}

//UserController
public String changeEmail(int userId, String newEmail) {   
    ...
    user.changeEmail(newEmail, company);
    
    ...
    _messageBus.sendEmailChangedMessage(userId, newEmail) // 로직을 타고 흐르면 메시지를 무조건 보냄
    
    return "OK"
}
```
이메일이 같은지 검사하는 부분을 컨트롤러로 옮겨서 해결할 수 있지만 비즈니스로직이 파편화되는 문제가 있다.

외부 시스템에 통보하는데에 필요한 데이터가 포함된 도메인 이벤트 클래스를 추가하여 컨트롤러를 복잡하지 않게 유지하며 처리할 수 있다.

ex) 도메인 이벤트 클래스
```java
public class EmailChangedEvent {
    public int userId {get;}
    public string newEmail {get;}
}
```

ex) 이메일이 변경될 때 이벤트를 추가하는 User
```java
public void changeEmail(String newEmail, Company company){
    Precondition.Requires(canChangeEmail() == null);
    
    if(Email == newEmail){
        return;
    }
    
    ...
    emailChangedEvents.add(new EmailChangedEvent(userId, newEmail)); // 
    ...
}
```

ex) 도메인 이벤트를 처리하는 컨트롤러
```java
public String changeEmail(int userId, String newEmail) {   
    ...
    user.changeEmail(newEmail, company);
    
    ...
    foreach(var ev in user.emaliChangedEvents) {
        _messageBus.sendEmailChangedMessage(ev.userId, ev.newEmail) // 도메인 이벤트 처리
    }
    
    return "OK"
}
```

도메인 이벤트는 컨트롤러에서 의사결정책임을 제거하고 해당 책임을 도메인 모델에 적용함으로써 외부 시스템과의 통신에 대한 단위테스트를 간결하게 한다. 