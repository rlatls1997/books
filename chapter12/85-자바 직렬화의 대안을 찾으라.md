객체 직렬화 : 자바가 객체를 바이트스트림으로 인코딩(직렬화)하고, 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘.

직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화할 수 있다.

## 85. 자바 직렬화의 대안을 찾으라

1997년 자바에 처음으로 직렬화가 도입되었다.

직렬화로 어렵지 않게 분산객체를 만들 수 있다는 장점이 있었으나,
보이지 않는 생성자, 성능, 보안, 유지보수성 등 위험성이 따랐다.

직렬화의 근복적 문제는 공격범위가 너무넒고 지속적으로 넓어지고 있다는 점인데,

ObjectInputStream의 readObject 메서드를 예로 들면 readObject메서드는 클래스패스안의 거의 모든 타입의 객체를 만들어낼 수 있는 생성자같은 존재인데, 역직렬화 가정에서 그 타입에 해당하는 모든 코드를 수행할 수 있다. 즉, 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.

**가젯**

역직렬화 과정에서 호출되어 위험한 동작을 수행할 가능성이 있는 메서드를 가젯(gadget)이라고 한다. 여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있다. 따라서 신중하게 제작된 바이트스트림만 역직렬화 해야한다.

**역직렬화 폭탄**

역직렬화에 시간이 오래걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다. 이런 스트림을 역직렬화 폭탄이라고 한다.

ex) 역직렬화 폭탄 예 - 아래 스트림의 역직렬화는 영원히 계속됨

```java
static byte[] bomb() {
	Set<Object> root = new HashSet<>();
	Set<Object> s1 = root;
	Set<Object> s2 = new HashSet<>();

	for(int i = 0; i<100; i++){
		Set<Object> t1 = new HashSet<>();
		Set<Object> t2 = new HashSet<>();
		t1.add("foo"); //t1, t2를 다른 Set으로 만들기위한 코드

		s1.add(t1); // 1. set에 set추가
		s1.add(t2);

		s2.add(t1); 
		s2.add(t2);

		s1 = t1; // 2. 넣은 자식set으로 참조 바꿔주기
		s2 = t2;
	}

	return serialize(root); //직렬화를 수행하는 메서드
}
```

**위 스트림의 역직렬화가 계속되는 이유**
HashSet인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야 한다는 데 있다.

이 반복문에 의해 노드가 2개의 자식을 갖고 있고 깊이가 100인 HashSet이 만들어진다.

이 HashSet을 역직렬화하기 위해서 hashCode() 메서드가 2^100번 넘게 호출되어야 하는데 이 코드는 계속될 뿐더러 어느부분이 잘못되었는지 알 수 없다.

**역직렬화의 문제 대처법**

바이트스트림을 역직렬화하는 일 자체가 스스로를 공격에 노출하는 행위이므로 **직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**

**크로스-플랫폼 구조화된 데이터 표현**

자바 직렬화를 사용하지 않아도 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많다.

이 방식들은 자바 직렬화 위험을 회피하면서 여러 플랫폼 지원, 우수한 성능, 활발한 커뮤니티 등 다양한 이점을 제공한다.

예시로 JSON과 프로토콜 버퍼가 있다.

**레거시 시스템에서 자바 직렬화를 배제할 수 없을때**

레거시 시스템에서 자바 직렬화를 배제할 수 없을때의 차선책은 **신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.**

직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 확신할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter, java 9)을 사용하자

객체 역직렬화 필터링은 데이터스트림을 역직렬화 하기 전에 필터링을 하는 기능이다. 블랙리스트, 화이트리스트를 사용하여 특정 클래스를 받아들이거나 거부할 수 있다.

화이트리스트를 사용하는 방식이 안전하다.