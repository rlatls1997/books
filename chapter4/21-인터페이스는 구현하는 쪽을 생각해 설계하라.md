## 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8 이전엔 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 수 없었다.

디폴트메서드를 선언하면 기존 인터페이스에 메서드를 추가해도 문제가 되지 않지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.

범용적으로 구현하는 것이 중요하다.

기존 구현체와 잘 어우러지지 않는 예로 org.apache.commons.collections4.collection.SynchronizedCollection이 있다.

SynchronizedCollection 은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다. 즉, 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼클래스이다.

SynchronizedCollection클래스는 자바8 Collection 인터페이스의 removeIf 메서드를 재정의하고 있지 않기 때문에. 이 클래스를 자바 8과 함께 사용한다면 removeIf의 디폴트 구현을 물려받게 되고 메서드 호출을 알아서 동기화해주지 못한다.

→ removeIf의 구현은 동기화에 대해 아무것도 모르기때문에..

따라서 SynchronizedCollection 클래스 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf를 호출하면 ConcurrentMonificationException이 발생하거나 예기치못한 동작으로 이어질 수 있다.

**이런 문제를 예방하기 위해**

예로 자바 플랫폼 라이브러리에선 구현한 인터페이스의 디폴트메서드를 재정의하고 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.

ex) Collections.synchronizedCollection이 반환하는 package-private 클래스의 removeIf 재정의

**디폴트 메서드는 컴파일에 성공해도 기존 구현체에 런타임 오류를 일으킬 수 있다**

기존 인터페이스에 디폴트메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다. 새로운 인터페이스를 만드는 경우라면

**디폴트 메서드가생겼어도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다**

디폴트메서드로 기존 인터페이스에 새로운 메서드를 추가했을 때의 부작용을 생각해야 한다.

릴리즈 전

인터페이스를 최소 세 개는 구현해봐야하고 각 인터페이스를 다양한 작업에 활용하는 클라이언트도 여러개 만들어서 테스트해봐야 한다.

인터페이스를 릴리즈한 후에도 결함을 수정할 수 있는 상황이 있지만 이런 상황에 의존해서는 안된다.