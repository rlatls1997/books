## 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

java.util.concurrent 패키지가 등작했다.

이 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

작업큐를 다음의 단 한 줄로 생성할 수 있게 되었다.

```java
ExecutorService exec = Executors.newSingleThreadExecutor();
```

다음과 같이 이 실행자에 실행할 태스크를 넘길 수 있다.

```java
exec.execute(runnable);
```

다음과같이 실자를 종료시킬 수 있다.(이 작업이 실패하면 VM자체가 종료되지 않을 것이다.)

```java
exec.shutdown();
```

실행자 서비스의 기능은 다음 기능들도 포함한다.

- 특정 태스크가 완료될 때까지 기다린다.
- 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.
- 완료된 태스크들의 결과를 차례로 받는다
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 다른 정적 팩토리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다.

스레드 풀의 스레드 개수는 고정할 수 있고 늘어나거나 줄어들게 설정할 수 있다.

**실행자 서비스 사용**

실행자 대부분은 java.util.concurrent.Executors의 정적팩토리로 생성할 수 있다.

평범하지 않은 실행자를 원한다면 ThreadPoolExecutor클래스를 직접 사용해도 된다.

작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋다. 특별히 설정할 게 없고 일반적인 용도에 적합하게 동작한다.

반면 무거운 프로덕션 서버에는 좋지 않다. CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임되어 실행된다.

가용한 스레ㄷ가 없다면 새 스레드를 하나 생성하기 때문에 CPU이용률이 극에 달할 수 있다.

따라서 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용하는 편이 훨씬 낫다.

**태스크**

작업 큐를 손수 만드는 일은 삼가야 하고 스레드를 직접 다루는것도 일반적으로 삼가야한다.

스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.

반면 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

작업 단위를 나타내는 핵심 추상 개념이 태스크다.

태스크에는 두 가지가 있다.

- Runnable
- Callable (Runnable과 비슷하지만 값을 반환하고 임으의 예외를 던질 수 있따)

그리고 태스크를 수행하는 일반적인 매커니즘이 바로 실행자 서비스이다.

태스크수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고 언제든 변경할 수 있다.

**포크 조인 태스크**

자바7이 되면서 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장되었따.

포크-조인 태스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행해준다.

포크-조인 풀을 이용해 만든 병렬스트림을 이용하면 포크-조인 태스크의 이점을 적은 노력으로 얻을 수 있다.