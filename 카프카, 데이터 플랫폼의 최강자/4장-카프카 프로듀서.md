# 4장. 카프카 프로듀서
카프카에서는 메시지를 생산해서 카프카의 토픽으로 매시지를 보내는 역할을 하는 애플리케이션, 서버 등을 모드 프로듀서라고 부른다.

키 값을 정해 해당 키를 가진 모든 메시지를 동일한 파티션으로 전송할 수 있다.

만약 키 값을 입력하지 않으면 파티션은 라운드로빈 방식으로 파티션에 균등하게 분배된다.

## 4.1 콘솔 프로듀서로 메시지 보내기
토픽을 만들고 그 토픽에 테스트 목적 등으로 토픽에 메시지를 보낼 수 있는 명령어를 제공함.
`/usr/local/kafka/bin/kafka-console.producer.sh`

--broker-list 옵션으로 클러스터 내의 모든 브로커 리스트를 입력한다.
ex)
```shell
/usr/local/kafka/bin/kafka-console-producer.sh
--broker-list peter-kafka001:9092,peter-kafka002:9092,peter-kafka003:9092
--topic peter-topic
```
나타난 프롬프트창에 내용을 입력하면 해당 토픽으로 메시지가 생성된다.

메시지는 kafka-console-consumer.sh로 확인가능
```shell
/usr/local/kafka/bin/kafka-console-producer.sh
--bootstrap-server peter-kafka001:9092,peter-kafka002:9092,peter-kafka003:9092
--topic peter-topic --from-beginning
```

## 4.2 자바와 파이썬을 이용한 프로듀서
책 p.145~ 확인

프로듀서에서 send()로 메시지를 보내는 방식은 3가지가 있다.

### 1. 메시지를 보내고 확인하지 않기
일부 메시지는 손실될 수도 있다.
손실가능성때문에 일반적인 서비스환경에서는 사용하지 않는다.

### 2. 동기전송
send()메시지가 반환한 Future를 기다리고 메시지 전송이 성공했는지 실패했는지 확인한다.
더 신뢰성있는 메시지 전송이 가능하다.

예외에는 재시도 가능 예외, 재시도 불가능한 예외가 있는데 재시도 가능 예외라면 다시 전송하여 해결할 수 있다.


### 3. 비동기 전송
send()메서드를 콜백과 같이 호출하고 브로커에서 응답을 받으면 콜백한다.

## 4.3 프로듀서 활용 예제
책 p.151~ 확인 (메시지 키를 사용하여 메시지를 생산하는 예제가 있다.)

## 4.4 프로듀서 주요 옵션
- bootstrap.servers : 카프카 클러스터는 클러스터 마스터라는 개념이 없기 때문에 클러스터 내 모든 서버가 클라이언트의 요청을 받을 수 있다. 하나의 호스트서버에 장애가 발생할경우 자동으로 다른 서버로 재접속을 시도한다.
- acks : 프로듀서가 카프카 토픽의 리더에게 메시지를 보낸 후 요청을 완료하기 전 ack(승인)의 수. 작으면 성능이 좋고 높으면 손실 가능성이 적다
  - 0일 때 : 프로듀서는 서버로부터 어떠한 ack도 기다리지 않는다. (손실가능성이 있지만 처리량이 높다)
  - 1일 때 : 리더는 데이터를 기록하지만 다른 모든 팔로워는 확인하지 않는다.
  - all또는 -1일 때 : 리더는 ISR의 팔로워로부터 데이터에 대한 ack를 기다린다.
- buffer.memory : 프로듀서가 카프카 서버로 데이터를 보내기 위해 잠시 대기할 수 있는 전체 메모리 바이트
- compression.type : 데이터를 압축하서보낸다면 어떤 타입으로 보낼지.(none, gzip ...)
- retries : 일시적인 오류로 전송실패시 데이터를 다시 보내는 횟수
- batch.size : i/o를 줄이기 위해 같은 파티션으로 보내는 데이터를 배치로 보낼때의 사이즈
- linger.ms : 배치식으로 보낼 경우 추가적인 메시지들을 위해 기다리는 시간. 만약 지정된 배치사이즈에 도달하면 이 옵션과 관계없이 메시지를 전송한다. (default = 0)
- max.request.size : 프로듀서가 보낼 수 있ㄴ느 최대 메시지 바이트 사이즈.(default = 1MB)

## 4.5 메시지 전송 방법
acks옵션을 어떻게 설정하는지에 따라 메시지 손실여부와 전송속도, 처리량등이 정해진다.

### 1. 메시지 손실가능성이 높지만 빠른 전송이 필요한 경우
일부 메시지 손실을 감안하더라도 빠른 전송이 필요하다면 acks=0으로 옵션을 설정한다.

### 2. 메시지 손실 가능성이 적고 적당한 속도의 전송이 필요한 경우
메시지를 카프카가 잘 받았는지 확인하면 확인시간이 추가되어 전송 속도가 약간 떨어진다.
acks=1로 설정하여 리더가 메시지를 잘 받았는지 확인할 수 있다.

(만약  replication factor가 1이라면, acks=all인 것과 같다.(복제를 하지 않아 팔로워가 없으니..))

### 3. 전송속도는 느리지만 메시지 손실이 없어야하는 경우
acks = all로 설정한다.
사용자의 입장에서 메시지가 절대 손실되지 않도록 할 수 있다.

**프로듀서의 acks=all과 브로커의 min.insync.replicas=1**
min.insync.replicas는 최소 리플리케이션 팩터를 지정하는 옵션이다.

만약 min.insync.replicas=1인 경우 acks=all로 설정해도 acks=1과 동일하게 동작한다.
min.insync.replicas=2인 경우는 리더 외 최소 1개의 팔로워까지도 메시지 전달을 확인하기 때문에 리더 선출작업이 발생해도 메시지 손실이 발생하지 않는다.

카프카 문서에 따르면, 손실없는 메시지 전송을 위해
- 프로듀서는 acks=all
- 브로커의 min.insync.replicas=2
- 토픽의 리플리케이션 팩터는 3
으로 권장하고 있다.


그러면 min.insync.replicas=3이 더 안전한게 아닌가? 라는 의문이 생길 수 있다.
min.insync.replicas=2로 해야하는 이유는,
만약 리더1, 팔로워2의 3개로 구성된 ISR에서 acks=all, min.insync.replicas=3인 상황을 가정해보면,
하나의 브로커가 다운되었을 때 살아있는 브로커는 2대뿐이라서 min.insync.replicas=3을 만족할 수 없기 때문에 클러스터 전체 장애와 비슷한 상황이 발생하게된다.
반면 min.insync.replicas=2로 설정하면 메시지의 손실도 없앰과 동시에 브로커 한 대가 다운되더라도 메시지를 전송할 수 있는 상태가 유지된다.


