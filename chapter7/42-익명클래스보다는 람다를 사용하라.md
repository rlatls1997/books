## 42. 익명클래스보다는 람다를 사용하라

JDK 1.1의 등장으로 함수 객체를 만드는 주요수단으로 익명클래스가 사용되었음

- 익명클래스의 인스턴스를 함수 객체로 사용 - 낡은기법

```java
Collecitons.sort(words, new Comparator<String>(){
	public int compare(String s1, STring s2){
		return Integer.compare(s1.length(), s2.length());
	}
});
```

자바 8부터는 추상메서드가 하나짜리인 인터페이스를 의미하는 함수형 인터페이스들의 인스턴스를 람다식을 사용해서 만들 수있따.

람다는 함수나 익명클래스와 개념은 비슷하지만 코드가 훨씬 간결하다

- 람다식을 함수 객체로 사용

```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

매개변수 (s1, s2)의 반환타입은 각각 (Comparator<String>), String, int 이지만 코드에선 언급이 없다.

컴파일러가 문맥을 살펴서 타입추론을 해주기 때문이다.

컴파일러가 타입추론을 하지 못하는 경우에는 프로그래머가 직접 명시해야한다.

**타입을 명시해야 코드가 더 명확할때만 제외하고는 람다의 모든 매개변수 타입은 생략하자**

람다대신 비교자 생성 메서드를 사용하면 코드를 더 간결하게 만들 수 있다.

```java
Collections.sort(words, comparingInt(STring::length));
```

추가로 자바8에서 List인터페이스에 추가된 sort메서드를 사용할 수 있다.

```java
words.sort(comparingInt(String::length));
```

---

람다는

이름이 없고 문서화를 하지못한다.

**따라서 코드 자체로 동작이 명확히 설며오디지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야한다**

람다는 길어도 세 줄 안에서 끊는것이 좋다.

**람다가 대체할 수 없는 것**

람다가 익명클래스를 완전히 대체한 것 같지만 그렇지 않다.
람다는 함수형 인터페이스에서만 쓰인다.

- 추상 클래스의 인스턴스를 만들 때 람다를 사용할 수 없으므로 익명클래스를 사용해야 한다.

람다에서의 this 키워드는 바깥 인스턴스를 가리킨다. 따라서

- 함수 객체가 자신을 참조해야 하는 경우 익명 클래스를 사용해야 한다.

람다도 익명클래스처럼 직렬화 형태가 구현별(가상머신별로)로 다를 수 있다. 따라서 람다를 직렬화하는 일은 극히 삼가야 한다.