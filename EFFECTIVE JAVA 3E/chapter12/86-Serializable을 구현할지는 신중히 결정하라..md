## 86. Serializable을 구현할지는 신중히 결정하라.

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스에 Serializable을 구현하면 된다.

직렬화를 지원하게 하는것은 쉽지만 길게보면 아주 비싼 일이다.

**Serializable 구현을 신중해야 하는 이유**

Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.

Serializable을 구현하고 나면 직렬화된 바이트 스트림 인코딩(직렬화형태)도 하나의 공개 API가 되기 때문에 이 클래스가 퍼지고 나면 영원히 직렬화를 지원해야한다.

커스텀직렬화가 아닌 자바의 기본 방식의 직렬화를 사용하면 직렬화 형태는 최소한 당시 클래스의 내부 구현 방식에 영원히 묶이게 된다.

기본 직렬화 형태에서는 클래스의 private, package-private 인스턴스 필드들마저 API로 공개되는 꼴이 된다.(캡슐화가 깨짐

뒤늦게 내부 구현을 수정하면 원래의 직렬화 형태와 달라져서 구버전 인스턴스를 역직렬화할 경우 실패할 것이다.

ObjectOutputStream.putFields, ObjectInputStream.readFields를 이용하면 원래의형태를 유지하면서 내부 표현을 바꿀 수 있지만 어렵고, 코드도 지저분하다.

따라서 직렬화 가능 클래스를 만들때는 길게 보고 고품질의 직렬화 형태도 주의해서 함께 설계해야한다.

---

**직렬화가 클래스 개선을 방해하는 경우 예시**

모든 직렬화된 클래스는 고유 식별 번호를 부여받는다

serialVersionUID라는 이름의 static final long필드로 이 번호를 명시하지 않을 경우 시스템이 런타임에 암호 해시 함수를 적용해서 자동으로 클래스 안에 생성해준다.

이 값을 생성할때는 클래스 이름, 구현한 인터페이스들, 대부분의 클래스 멤버들이 고려된다. 이들 중 하나라도 수정한다면 직렬버전 UID로 변한다.

따라서 자동생성되는 직렬버전에 의존하면 호환성이 쉽게 깨지게 된다.

**Serializable 구현은 버그와보안구멍이 생길 위험을 높인다**

객체는 생성자를 사용해서 만드는게 기본이다.

따라서 직렬화는 객체 생성의 기본 메커니즘을 우회하는 객체 생성 기법이다.

역직렬화는 일반 생성자의 문제가 그대로 적용되는 ‘숨은 생성자’와 같다. 이 객체 생성 방식은 전면에 드러나지 않아서 ‘생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다볼 수 없도록 해야한다’는 사실을 떠올리기 힘들다.

결국 이는 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출되게 된다.

**Serailizabvle를 구현한 클래스를 릴리즈할때 테스트할 것이 많아진다**

직렬화클래스가 수정되면 신버전 인스턴스를 직렬롸한 후 구버전으로 역직렬화할 수 있는지, 반대도 가능한지 테스트해야한다.

클래스를 처음 제작할 때 커스텀직렬화형태를 잘 설계했다면 이런 테스트 부담을 줄일 수 있다.

**Serializable구현여부는 신중이 고려해야 한다**

Serializable구현에 따르는 비용은 적지 않다.

클래스를 설계할 때 비용, 이득을 잘 따져야 한다.

**상속용 클래스는 대부분 Serailizable을 구현하면 안되고, 인터페이스도 대부분Serializable을 확장해서는 안된다.**

이런 클래스나 인터페이스를 확장하거나 구현해야할 경우 구현부에서 큰 부담일 지게 된다.

예외로, Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 경우라면 어쩔 수 없다.

상속용 클래스 중 Serializable을 구현한 예로 Throwable, Component가 있다.

### 인스턴스 필드가 직렬화와 확장이 모두 가능한 경우 주의할 점

**finalize 재정의 막기**

인스턴스 필드 값 중 불변식을 보장해야할 게 있다면 하위클래스에서 finalize메서드를 재정의하지 못하게 해야한다. finalize메서드를 자신이 재정의하면서 final로 선언하면 된다.

이렇게 하지 않으면 finalizer공격을 당할 수 있다.

**readObjectNoData메서드**

인스턴스 필드 중 기본값(0, false, null..)으로 초기화되면 위배되는 불변식이 있을 경우에는 클래스에 readObjectNoData메서드를 반드시 추가해야한다.

ex) 상태가 있고, 확장가능하고 직렬화가능한 클래스용 readObjectNoData메서드

```java
private void readObjectNoData() throws InvalidObjectException {
	throw new InvalidObjectException("스트림 데이터가 필요합니다");
}
```

자바 4에 추가된 이 메서드는 기존의 직렬화가능 클래스에 직렬화 가능 상위 클래스를 추가하는 경우를 위한 메서드이다. (?)

---

Serializable을 구현하지 않기로 할 때는 한가지만 주의하면 된다.

상속용 클래스인데 직렬화를 지원하지 않으면 그 하위클래스에서 직렬화를 지원하려 할 때 부담이 늘어난다. 보통 이런 클래스를 역직렬화하려면 그 상위 클래스는 매개변수 없는 생성자를 제공해야하는데, 이런 생성자를 제공하지 않으면 하위클래스에서는 어쩔 수 없이 직렬화 프록시 패턴을 사용해야한다.

**내부클래스는 직렬화를 구현하지 말아야 한다**

내부클래스는 바깥 인스턴스의 참조와 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가된다. 이런 필드들은 클래스 정의에 어떻게 추가되는지 정의되어있지 안항서 기본 직렬화 형태가 분명하지 않기 때문이다.

단, 정적 멤버 클래스는 Serializzable을 구현해도 된다.