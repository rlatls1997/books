# 12장. 자바 메모리 모델과 스레드

## 1. 들어가며
멀티태스킹은 운영체제에선 없어서 안될 기능.

컴퓨터의 연산 성능과 저장, 통신 성능의 격차가 너무 크기때문에 남는 시간에 자원을 최대한 사용하기 위해 필요

그 외에도 서비스를 여러 클라이언트에세 동시에 제공하기 위해서도 필요

자바언어와 가상 머신은 동시성 프로그래밍의 어려움을 낮춰주는 도구를 많이 제공한다.

이 장에선 가상 머신이 머맅스레딩을 구현하는 방법과, 스레드들이 데이터를 놓고 경합하며 발생하는 문제들을 살펴본다.

## 2. 하드웨어에서의 효율과 일관성
먼저 물리적인 컴퓨터의 동시성 문제를 생각해보기.

- 프로세서는 데이터를 읽고 작업 결과를 저장함.
- 작업 결과를 저장하기 위해 메모리가 필요
- 하지만 메모리는 프로세서보다 느림
- 그래서 둘 사이에 캐시 계층이 필요
- 작업결과를 캐시에 저장해뒀다가 캐시에서 메모리로 동기화

현대의 컴퓨터는 위와 같이 동작하여 프로세서와 메모리 속도의 격차를 해결한다.

하지만 위와 같은 동작방식으로 인해 캐시 일관성 문제가 발생함.

일관성 문제 해결을 위해 여러 프로토콜이 있음(MSI, MESI, MOSI, 시냅스, 파이어플라이, 드로곤 프로토콜 등..)

`메모리모델`은 위와 같은 프로토콜을 이용하여 특정 메모리나 캐시를 읽고 쓰는 절차를 말함.

자바 가상 머신은 자체 메모리 모델을 가지고 있음

### 비순차 실행 최적화
캐시를 늘리는 방법 외에 비순차 실행으로 프로세서의 컴퓨팅 능력을 향상시킬 수 있음

`비순차 실행`에선 입력코드에 기술된 명령의 순서와 실제로 명령이 실행되는 순서가 다를 수 있음(물론 결과는 순차적으로 실행했을때와 같도록 재구성)

프로세스의 비순차 실행 최적화와 비슷하게 자바 가상 머신의 JIT컴파일러는 명령어 재정렬이라는 최적화를 수행함.

## 3. 자바 메모리 모델
자바 메모리 모델을 통해 다양한 하드웨어 및 운영체제의 서로 다른 메모리모델로 부터 자바 프로그램을 보호할 수 있다.

자바 메모리모델은 JDK5에야 완성됨.

### 메인 메모리와 작업 메모리
자바 메모리모델의 주 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정하는 것

(여기서 말하는 `변수`에는 인스턴스 필드, 정적 필드, 배열 객체의 원소는 포함되나 지역변수, 메서드 매개변수 등 스레드에서 고유한 스택 영역에 포함되는 값은 포함되지 않음)

<img src="https://github.com/user-attachments/assets/b2c39da2-3959-4d55-9dbf-165b70da1a9c" width="600">
자바 메모리 모델에서의 상호작용
- 자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다.(물리적 메인 메모리가 아닌 가상 머신이 관리하는 메모리)
- 각 스레드는 자체 작업메모리를 갖는다. 작업메모리는 프로세서의 캐시와 비슷한 역할을 한다.
- 작업메모리에는 해당 스레드가 사용하는 변수가 저장된 메인 메모리의 복사본이 담겨있다.
- 스레드의 모든 연산은 작업메모리에서 수행되며 메인 메모리의 데이터를 직접 조작할 수 없다.
- 스레드끼르는 서로의 작업메모리에 직접 접근할 수 없다.(메인메모리를 거쳐가야함)

메인메모리는 하드웨어 매모리에 대응하고, 작업메모리는 레지스터와 캐시에 대응한다고 보면됨.
-> 실제로 가상 머신은 실행 성능을 높이기 위해 작업메모리를 레지스터나 캐시에 미리 저장해둔다.

### 메모리 간 상호작용
자바메모리모델은 메인메모리에서 작업메모리로 변수를 복사하고 작업메모리를 다시 메인메모리로 동기화하는 방법을 다음 여덟가지로 정의했다.

- 잠금 : 메인 메모리의 변수를 특정 스레드만 사용할 수 있는 상태로 만듬
- 잠금해제 : 잠겨있는 변수를 잠금해제
- 읽기 : 메인메모리의 변수값을 작업메모리로 전송
- 적재 : 읽기연산으로 메인메모리에서 얻어온 값을 작업메모리의 변수에 복사
- 사용 : 작업메모리의 변수값을 실행엔진으로 전달
- 할당 : 실행엔진에서 받은 값을 작업메모리의 변수에 할당
- 저장 : 작업메모리의 변수값을 메인메모리로 전송
- 쓰기 : 저장연산으로 작업메모리에서 얻어온 값을 메인메모리의 변수에 기록

위 작업에서 읽기-적재, 저장-쓰기는 순서대로 수행되어야 한다.(바로 이어서 수행될 필요는 없다. 순서대로만 수행되면 됨)

앞의 여덟가지 기본 연산을 수행할때 지켜야 하는 규칙도 있다
- 읽기-적재, 저장-쓰기는 단독으로 수행될 수 없다.
- 스레드는 할당 연산을 버릴 수 없다.(=작업메모리에서 변수값이 변경되면 메인메모리로 동기화해야함)
- 스레드는 작업메모리의 변수값을 아무 이유 없이(할당없이) 메인메모리로 동기화할 수 없다.
- 변수는 메인메모리에서만 새로 생겨날 수 있다.
- 변수는 한 번에 한 스레드만 잠글 수 있다.(같은 스레드면 여러변 잠글 수 있다)
- 변수를 잠그면 작업메모리의 변수값은 지워진다.
- 잠겨있지 않은 변수에 대해 잠금해제를 수행할 수 없다
- 다른 스레드가 잠금 변수에 대해 잠금해제를 수행할 수 없다.
- 잠금을 해제하려면 변수를 메인메모리로 동기화해야한다.

### volatile 변수용 특별 규칙
volatile키워드는 JVM이 제공하는 가장 가벼운 동기화 메커니즘

JVM은 volatile을 위한 특별한 접근 규칙을 정의한다

**1. 모든 스레드에서 이 변수를 투명하게 볼 수 있다.(= 가시성을 보장한다)**

한 스레드가 값을 수정하면 다른 스레드들도 새로운 값을 즉시 알게된다.

하지만 volatile변수를 사용한 작업이 동시성 환경에서 안전하다고 착각해선 안된다.

각 스레드 작업메모리에서는 volatile변수의 일관성에 문제가 없다.

하지만 자바의 산술연산자가 원자적이 아니기 때문에 volatile변수라도 멀티스레드 환경에서 완벽하게 안전하지는 못하다
ex)
```java
public class Main {

	public static volatile int race = 0;

	public static void main(String[] args)  {
		try (ExecutorService executor = Executors.newFixedThreadPool(20)) {
			// 20개의 작업 제출
			for (int i = 1; i <= 20; i++) {
				executor.submit(() -> {
					for (int j = 0; j < 10000; j++) {
						race++;
					}
				});
			}
		}

		System.out.println("race:" + race);
	}
}
```
위 코드 race를 10,000번 증가시키는 작업을 20번 수행하는 코드이다. 

실행결과는 200,000이 아니다.

스레드에서 `사용` 단계에 있는 동안에 다른 스레드에서 race값을 `저장-쓰기`연산을 수행한다.
이후 `사용` 단계를 마친 스레드에서 과거의 값을 `저장-쓰기`연산을 통해 메인스레드에 동기화하는 일이 발생한다.

volatile변수는 가시성만 보장하기 때문에 다음 두 규칙을 충족하지 못한다면 락을 활용하여 원자성을 보장해야한다.
- 연산의 결과가 변수의 현재 값과는 무관하거나, 변수의 값을 수정하는 스레드가 하나뿐임을 보장한다.
- 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않는다.

ex) volatile을 이용하는게 적합한 예시
```java
volatile boolean shutdown;

public void shutdown() {
	shutdown = true;
}

public void doWork() {
	while(!shutdown) {
		//비즈니스로직
	}
}
```
위 코드는 shutdown()메서드가 호출되면 모든 스레드에서 실행중인 doWork()메서드가 즉시 종료됨을 보장한다.



**2. volatile로 선언한 변수의 두 번째 특성은 명령어 재정렬 최적화를 막아준다**

아래는 스레드 A에서는 어떤 설정을 수행하고, B에서는 A에서 설정을 한 값을 사용하는 코드를 실행하는 예시이다.

```java
Map configOptions;
char[] configText;
volatile boolean initialized = false; //반드시 volatile로 선언해야하는 코드

// A스레드에서 실행되는 코드
// 설정이 완료되면 다른 스레드에 설정을 읽어 가도 좋다고 통보함
configOptions = new HashMap();
configText = readConfigFile(fileName);
processConfigOptions(configText, configOptions);
initialized = true;

// B스레드에서 실행되는 코드
while(!initlaized){
	sleep();
}

doSomethingWithConfig();
```

명령어 재정렬이 이루어지면 스레드 A의 `initialized = true`가 조기에 실행되어 스레드 B에서 오류가 발생할 수 있다.

volatile키워드는 이런 상황을 막아준다.

명령어 재정렬은 프로그램의 결과에 영향을 끼치지 않는 선에서만 발생한다

**동시실행 환경에서 안전성을 보장해주는 도구 중 왜 volatile이 중요한가?**

- 다른 동기화 도구보다 코드를 더 빠르게 실행한다.

특정 상황에서 락 방식보다 성능이 좋다.

- volatile변수의 읽기 성능은 일반 변수와 거의 같다.

하지만 쓰기는 더 느릴 수 있다. 프로세서가 명령어를 재정렬하지 못하도록 하기 위해 네이티브 코드에 메모리 장벽 명령어 다수를 끼워넣기 때문이다.

(메모리장벽:volatile키워드는 재정렬을 막기 위해 메모리장벽 역할을 하는 `lock addl $0x0, ($esp)`작업이 추가로 수행된다. 이 명령은 `ESP 레지스터 값에 0을 추가하라`는 뜻으로 노옵(아무 작업도 하지 않음)을 뜻한다. lock접두어는 프로세서의 캐시를 메인메모리에 쓰는 기능을 하며, 자바 메모리 모델에서의 `저장-쓰기`연산의 역할을 한다)


**long과 double 변수용 특별 규칙**

자바 메모리 모델의 연산(잠금, 적재 할등 등..)은 원자적이어야 하나 

하지만 64비트 데이터 타입인 long, double에는 특별 규칙이 적용된다.

JVM은 volatile로 지정되지 않은 64비트 데이터의 읽기와 쓰기를 32비트 연산 2개로 나눠서 처리할 수 있다.

이로 인해 자바 메모리 모델의 연산에 대한 원자성을 보장할지를 JVM이 선택할 수 있따.

volatile로 선언되지 않은 long, double 변수를 여러 스레드가 공유하고 동시에 읽고 쓴다면, `반만 수정된`값을 읽는 현상이 발생할 수 있다.(거의 발생하지는 않는다., 실험결과 주요 플랫폼의 64비트 JVM에서 비원자적 접근이 발생하지 않았다.)

하지만 일부 JVM(32비트 x86 플랫폼용 머신 등)에서 long타입을 비원자적으로 처리할 위험이 있다.

이런 문제를 해결하기 위해 JDK9 핫스팟 가상머신에선 모든 데이터타입에 원자적즈로 접근하도록 하는 메개변수 `-XX:+AlwaysAtomicAccesses`를 추가했다.

(double타입의 경우 요즘 프로세서들은 대부분 부동소수점데이터 전용 유닛을 탑재하여 32비트 JVM이라해도 비원자적 접근 문제가 일어나지 않는다)

결론은,
스레드 경합이 뻔한 상황이 아니라면 long, double이라고 해서 volatile로 선언할 필요는 없다

**원자성, 가시성, 실행 순서**

자마 메모리 모델의 전체적은 특징.

자바 메모리모델은 동시성 처리에서 원자성, 가시성, 실행순서를 어떻게 처리하는지로 구성된다.

- 원자성

자바메모리모델의 작업은 원자적이다. (long, double은 비원자적일 수 있으나 드문 예외임)

원자성을 더 넓은 범위로 보장해야할땐 잠금, 잠금해제 연산을 제공한다.

JVM은 잠금-잠금해제 연산을 직접 제공하지 않고 한단계 추상화된 바이트코드 명령어인 monitorenter, monitorexit을 이용하도록 한다.

이는 synchronized 키워드로 동기화한 블록에 해당한다.

- 가시성

공유변수의 값을 한 스레드가 수정하면 다른 스레드가 즉시 알 수 있음을 의미한다.

volatile외에 synchronized와 final키워드를 사용하여 가시성을 확보할 수 있따.

synchronized키워드는 `변수의 잠금을 해제하기 전 메인메모리로 다시 동기화해야한다`는 규칙으로 가시성을 확보한다.

final키워드는 `생성자에서 초기화되며, 스레드는 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없다`는 규칙으로 가시성을 확보한다.

- 실행순서

자바 프로그램의 실행순서는 `명령어 재정렬`에 의해 실제 코드의 순서대로 실행되지 않을 수 있다.

순서보장을 위해 vaoltile과 synchronized 키워드를 사용할 수 있다.

volatile은 `명령어 재정렬을 금지한다`는 규칙이 있다.

synchronized키워드는 `락을 소유한 단 하나의 스레드만이 변수에 접근할 수 있다`라는 규칙에 의거하여 작업 순서를 정한다. synchronized 블록 두개가 같은 락을 공유하는 경우 반드시 순서대로 수행된다.


**선 발생 원칙**

모든 실행순서를 volatile과 synchronized로만 처리하면 많은 연산이 장황해진다.

선발생원칙으로 동시성 환경에서 두 작업의 충돌가능성 판단 문제를 해결할 수 있따.

`선 발생 원칙`은 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다.

`작업 A가 작업 B보다 선 발생한다` 라고 하면, `작업 B가 수행되기 전에 작업 A의 수행결과를 작업 B에서 관찰할 수 있따`라는 의미이다.
ex) 선 발생 원칙 예(1)
```java
i = 1; //스레드 A에서 수행
j = i; //스레드 B에서 수행
i = 2; //스레드 C에서 수행
```

스레드 A의 연산이 스레드 B의 연산보다 먼저 발생해야한다고 가정하자.

그러면 B의 연산이 실행된 후 j값은 1이라고 할 수 있다.

A, B의 선후관계를 유지한 상태로 C가 A와 B 사이에 끼어든다고 가정해보자.

C와 B의 선 발생 관계가 없다면 j의 값은 확실하지 않다.

C가 변수 i에 미치는 영향을 B가 관찰할 수도, 관찰하지 못할 수도 있기 때문이다.

B는 낡은 데이터를 읽을 위험이 있으므로 멀티스레드 환경에서 안전하지 못하다.

**자연스러운 선 발생 관계**

두 작업 사이의 관계가 다음 목록에 없고 이 목록으로부터 추론할 수 없다면 실행 순서가 보장되지 않는다.(JVM이 마음대로 순서를 바꿀 수 있다)

- 프로그램 순서 규칙 : 한 스레드 안에서 `제어 흐름 순서`에 따라 읖의 연산이 뒤따르는 연산보다 선발생한다.
- 모니터 락 규칙 : 잠금 해제 연산은 `같은 락`에 대한 잠금 연산보다 선발생한다.
- 휘발성 변수 규칙 : volatile변수의 쓰기 연산은 같은 변수에 대한 읽기 연산보다 선발생한다.
- 스레드 시작 규칙 : Thread객체의 start()메서드는 해당 스레드에서 어떤 작업보다 선발생한다
- 스레드 종료 규칙 : 스레드의 모든 작업은 해당 스레드의 종료 감지보다 선 발생한다.
- 스레드 인터럽트 규칙 : Thread의 interrupt()메서드 호출은 인터럽트되는 스레드가 인터럽트 이벤트 발생 감지보다 선 발생한다.
- 종료자 규칙 : 객체 초기화는 finalized()메서드 시작보다 선 발생한다.
- 전이성 : 연산 A가 연산 B보다 선 발생하고, 연산 B가 연산 C보다 선 발생한다면, A가 C보다 선 발생한다고 결론지을 수 있다. 

ex) 선 발생 원칙(2)
```java
private int value = 0;

public void setValue(int value){
	this.value = value;
}

public int getValue(){
	return value;
}
```

코드가 다음 순서로 실행된다고 가정하면
1. 스레드 A에서 setValue(1) 호출
2. 스레드 B에서 getValue() 호출

스레드 B에서 얻는 반환값은? => 알수없다.

위에서 적용가능한 설 발생 규칙이 없기 때문이다. 

이 작업을 스레드에서 안전하게 만드려면 
getter, setter를 synchronized로 만들거나, value를 volatile로 선언하면 된다.

## 4. 자바와 스레드
### 스레드 구현
JDK20까지 자바에서는 스레드가 프로세서 자원 스케줄링의 최소단위이다.

하지만 JDK21에서는 가상스레드가 도입되어 달라졌다. (12.5절에서..)

자바스레드구현이 아닌 일반 애플리케이션 관점에서 스레드가 구현되는 방식을 살펴본다.

스레드의 구현방법
- 커널 스레드(1:1)
- 사용자 스레드(1:N)
- 사용자 스레드와 경량 프로세스의 하이브리드 구현(M:N)

**커널 스레드 구현**

커널 스레드는 운영체제 커널에서 직접 지원하는 스레드이다.

프로그램은 일반적으로 커널 스레드를 직접 사용하지 않고 커널 스르데의 고수준 인터페이스인 경량 프로세스를 이용함.
(경량 프로세스 = 스레드)

<img src="https://github.com/user-attachments/assets/4a14eba1-ead3-41cc-adfd-f49dae84d349" width="600">

경량 프로세스 각각은 독립적 단위로 스케줄링되며 경량 프로세스 하나가 시스템 호출에서 블록되더라도 전체 프로세스는 역향을 받지 않음

경량 프로세스는 다음의 한계가 있는데,
- 커널 스레드를 기반으로 구현되기 때문에 생성, 소멸, 동기화 등 스레드 연산이 시스템 호출로 이루어지며 이는 사용자 모드와 커널 모드 전환을 수반하기 때문에 실행 비용이 상대적으로 높음
- 경량 프로세스 하나가 커널 스레드 하나에 매핑되기 때문에 일정량의 커널 자원을 소모한다. 따라서 시스템이 지원할 수 있는 경량 프로세스의 개수에 제한이 있다

**사용자 스레드 구현**

1:N으로 구현됨

사용자 스레드는 온전히 사용자 공간에서 구현되는 스레드 라이브러리를 가리킨다.

사용자 스레드의 생성, 소멸, 동기화, 스케줄링은 모두 커널의 도움 없이 사용자 공간에서 처리되기 때문에 빠르고 저렴하며 더 많은 스레드를 지원할 수 있다.

<img src="https://github.com/user-attachments/assets/01df17b1-a756-4e11-98ef-47144e71c8a6" width="600">

시스템 커널의 지원이 필요없다는 것은 장점이자 단점이다.

스레드 생성, 소멸, 동기화, 스케줄링 등 모든 작업을 사용자 프로그램 자체에서 처리해야하기 때문에 어렵고 복잡하다.

**하이브리드 구현**

커널 스레드와 사용자 스레드를 함께 이용하는 구현 방법. M:N

사용자 스레드에 의해 성성, 소멸, 스케줄링 비용이 저렴하고 감당할 수 있는 동시성 규모가 커진다.

운영체제가 제공하는 경량 프로세스(스레드)는 사용자 스레드와 커널 스레드 사이에서 가교 역할을 한다.
덕분에 커널이 지원하는 스레드 스케줄링과 프로세서 매핑 기능을 활용할 수 있다.

또한 사용자 스레드의 시스템 호출이 경량 프로세스에 의해 수행되므로 프로세스 전체가 완전히 블록될 위험이 크게 줄어든다.

<img src="https://github.com/user-attachments/assets/d98c409f-c3d8-4b44-a713-b77d3c6fbc90" width="600">

**자바 스레드 구현**

자바 스레드 구현 방식은 JVM에 따라 다를 수 있다

핫스팟은, 자바 스레드 각각이 중간에 간접 참조 없이 운영 체제의 기본 스레드에 직접 매핑된다.


### 자바 스레드 스케줄링
스레드 스케줄링 : 시스템이 프로세서 사용 권한을 스레드에 할당하는 일

**협력적 스케줄링**

스레드 실행 시간을 스레드가 스스로 제어함. 일을 마친 스레드는 다른 스레드로 전환되도록 시스템에 알려야함

구현하기 쉽고 동기화 문제가 일어나지 않는다.

단점은 스레드 실행시간을 제어할 수 없어서 스레드에 문제가 있는 경우 프로그램이 멈출 수 있다.

**선점형 스케줄링**

각 스레드의 실행시간을 할당함.

스레드때문에 프로그램이 먹통이 되는 일을 막을 수 있따.

자바는 선점형 스케줄링.


자바에선 스레드 우선순위를 설정할 수 있는데, 이를 통해 스레드에 대한 실행시간을 증감하도록 운영체제에 권고할 수 있따.

하지만 OS의 스레드 우선순위 단계와 일치하지 않으면 예상 결과와 다르게 동작할 수 있따.

<img src="https://github.com/user-attachments/assets/314e5c22-9c27-4e83-b0d8-f8bebd8675c5" width="600">

따라서 스레드 우선순위에 너무 우전해선 안된다.

### 상태전이
자바 언어에서 스레드의 상태는 촛 여섯가지이다.

- 신규
- 실행중
- 무기한대기
- 시간제한대기
- 블록 : 대기와는 다르다
- 종료
  
<img src="https://github.com/user-attachments/assets/6e9a45ba-027c-49a7-b201-4b91275d6d93" width="600">

## 5. 자바와 가상스레드
### 커널 스레드의 한계
자바의 기존 동시성 프로그래밍은 요즘의 웹 애플리케이션과 어울리지 않는다.

JVM은 주로 1:1커널 스레드 모델을 채택했다.

자바 스레드가 운영체제 스레드에 매핑되면서 전환과 스케줄링 비용이 커지고 시스템이 수용가능한 스레드의 수도 크게 제한되엇따.

요즘 웹 애플리케이션은 요청당 실행 시간이 매우 짧아지고 요청 수가 매우 많아졌다. 이로 인해 사용자 스레드 전환의 부하가 상당해졌다

### 코루틴의 귀환
코루틴은 협력적 스케줄링 방식으로 동작하는 비동기 프로그래밍의 일종. 함수.

특정 지점에서 실행을 멈추고, 그 지점에서 다시 실행을 이어나갈 수 있음.

코루틴의 스택은 수백 바이트에서 수 킬로바이트 정도로, 핫스팟의 스레드 스택 크기에 비해 훨씬 가볍다.

따라서 코루틴은 스레드와 달리 수십만개씩도 공존할 수 있다.

### 가상스레드: 자바의 해법
2017년 OpenJDK 룸 프로젝트의 출범으로 JDK21에 반영된 가상스레드

<img src="https://github.com/user-attachments/assets/44b4cb1a-3658-4ab7-9c65-8f3d021b7bdc" width="600">

가상스레드는 플랫폼스레드(기존 자바 스레드)와 N:1 관계.

가상스레드 하나가 블록되면 플랫폼 스레드에서 다른 가상 스레드의 작업을 진행한다.

이런식으로 커널스레드는 문맥전환없이 애플리케이션 코드를 실행할 수 있다.

새로운 모델은 현재의 스레드 관련 API를 최소한만 수정하도록 설꼐하여 큰 수정없이 가상 스레드를 이용할 수 있다.

가상 스레드의 이점은 I/O작업이 많고 스레드 전환이 자주 일어나는 상황에서 드러난다. 작업 형태에 따라 적절하게 적용해야함.