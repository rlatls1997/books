# 2장 주변 친구

모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계하는 예.

앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한해 인근의 친구 목록을 보여주는 시스템을 구현한다.

1장 근접성 서비스 예시와의 차이는,<br>
근접성 서비스 예시에서 사업장 주소는 정적인 반면 주변 친구의 위치는 자주 바뀔 수 있다.

## 1단계: 문제 이해 및 설계 범위 확정
(책이 시스템 설계 면접 기법에 대한 예기인 만큼 면접에서 질문을 통해 설계 범위를 정해나가는 과정의 예시가 있음)

위와 같은 서비스를 구현하기 위한 질문으로 다음과 같은 질문으로 설계 범위를 좁힐 수 있다.
- 지리적으로 얼마나 가까워야 주변에 있다고 할 수 있는지?
- 두 사용자의 거리는 직선거리인가? 아니면 실질적 이동거리인가?
- 얼마나 많은 사용자가 이 앱을 사용할 것인가?
- 사용자의 이동 이력을 보관할 것인가?
- 비활성상태의 사용자 처리는 어떻게 할것인가?
- 법적 문제도 고려를 해야하는가?

이러한 질문들로 다음과 같이 요구사항과 설계 범위를 확정할 수 있다.
- 기능 요구사항
- 비기능 요구사항
- 개략적 규모 추정

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 개략적 설계안
메시지의 효과적 전송을 가능하게 할 설계안이 요구되는 시스템이다.

먼저 순수한 p2p방식을 고려할 수 있다.<br>
모바일 단말의 통신 연결상태 문제나 사용할 수 있는 전력이 충분하지 않은 문제가 있다.

다른 설계로는 공용 백엔드를 사용하는 것을 생각해볼 수 있다.<br>
설계가 간단해지지만 큰 규모에 적용하기 쉽지않다.


### 설계안
먼저 소규모 백엔드를 위한 설계안을 만들고 상세 설계를 진행하면서 더 큰 규모에 맞게 확장한다.
- 로드밸런서 : api서버 및 양방향 유상태 웹소켓 서버 앞단에 위치하여 부하를 고르게 분산
- api서버 : 무상태 api서버 클러스터.
- 웹소켓 서버 : 친구 위치 정보 변경을 실시간에 가깝게 처리하는 유상태 서버 클러스터. 각 클라이언트는 클러스터 중 한대와 지속적인 웹소켓 연결을 유지함
- 레디스 위치 정보 캐시 : 활성 상태 사용자의 가장 최근 위치 정보를 캐시하는데에 사용. TTL필드를 사용함
- 사용자 데이터베이스 : 사용자, 사용자 친구 관계 정보 저장
- 위치 이동 이력 데이터베이스 : 사용자의 위치 변동 이력 보관
- 레디스 펍/섭 서버
  - 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트를 발행
  - 채널(토픽)을 구독중인 대상은 메시지를 수신
  - 새로운 채널을 생성하는것의 비용이 매우 저렴하고 기가바이트급 메모리를 갖춘 서버에서는 수백만개의 채널도 생성할 수 있을만큼 가볍다.

**주기적 위치 갱신**
위치 갱신 과정은 다음과 같다.
1. 모바일 클라이언트는 위치가 변경된 사실을 로드밸런서에 전송한다.
2. 로드밸런서는 위치 변경 내역을 웹소켓 서버로 전송한다.
3. 웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장한다.
4. 웹소켓 서버는 새 위치 정보를 위치 정보 캐시에 보관한다.
5. 웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행한다.
6. 레디스 펍/섭 서버의 채널에 발행된 위치 변경 이벤트는 모든 구독자에게 브로드캐스트된다.
7. 구독자의 웹소켓 연결 핸들러가 위치한 웹소켓 서버는 메시지를 받아서 구독자와의 거리를 새로 계산한다.

평균 400명의 친구가 있으며 온라인상태인 사용자를 10%라고 가정하면 한 사용자의 위치가 바뀔때마다 위치 정보 전송은 40건일 발생하게 된다.

**위치정보저장에 데이터베이스를 사용하지 않는 이유는?**<br>
주변 친구 기능은 사용자의 현재 위치만을 이용하기 때문에 사용자 위치는 하나만 보관하면 충분하고<br>
사용자 위치 정보는 영속성을 보장할 필요가 없다.<br>
TTL기반으로 활성상태를 체크하여 불필요한 데이터를 자동을 제거하기도 하는데

레디스가 이런 목적에 적합하다.

## 3딘계: 상세 설계
기능면에서는 위에까지도 충분하지만..

- 위치정보를 30초 주기로 갱신해야함
- 평규적으로 한 사용자가 400명의 친구를 갖는다고 가정
- 매일 주변 친구 검색 기능을 활용하는 사용자를 1억명으로 가정
- 동시에 시스템을 이용하는 사용자의 수가 1천만이라고 가정
위 요구사항을 만족해야므로 시스템의 규모를 늘릴 필요가 있다. 

### 중요 구성요소별 규모 확장성
**웹소켓 서버**<br>
웹소켓 서버는 유상태서버이기 때문에 기존 서버를 제거할때는 주의해야한다.<br>
노드를 실제로 제거하기전에 기존 연결부터 종료될 수 있도록 해야한다.

로드밸런서에서 제거할 노드와의 연결을 끊어서 새로운 웹소켓 연결이 만들어지지 않도록 하고 모든 연결이 종료된 후 서버를 제거한다.

**레디스 펍/섭 서버**<br>
레디스 펍/섭 서버는 채널 생성 비용이 매우 저렴하다.<br>
따라서 모든 친구의 채널을 친구의 상태에 상관없이 생성한다.

만약 활성상태에 따라 채널에 이벤트를 발행할지 말지를 결정한다면 구현이 더 복잡해질 것이다.<br>
`성능이 충분하다면 작업을 단순하게 만들 수 있는 방향으로 생각해보자.`

**얼마나 많은 레디스 펍/섭 서버가 필요한가?**
메모리 측면에서는 큰 문제가 없으나 대량의 사용자에 대해서 펍/섭 서버가 구독자에게 전송해야하는 위치 정보 업데이트양은 상당하다.<br>
레디스 펍/섭 서버의 병목은 메모리가아닌 CPU이고 이런 문제를 해결하기 위해 분산 레디스 펍/섭 클러스터가 필요하다.

**분산 레디스 펍/섭 서버 클러스터**
수백대의 레디스 펍/섭 서버에 채널을 분산하기 위해 주키퍼와 같은 서비스탐색 컴포넌트를 사용할 수 있다.<br>
이 서비스에서는 서비스탐색 컴포넌트의 다음 두 가지 기능을 사용한다
1. 가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는데에 필요한 ui나 api
2. 클라이언트(웹소켓서버)로 하여금 `값`에 명시된 레디스 펍/섭 서버에서 발생한 변경 내용을 구독할 수 있도록 하는 기능

레디스 펍/섭 서버는 메시지를 발행할 채널이나 구독할 채널을 정할때 해시링(키에 매달린 값(클러스터내의 펍/섭 서버))을 참조한다.

웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정은 다음과 같다.
1. 웹소켓서버는 해시링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.<br>
해시링의 정확한 정보는 서비스 탐색 컴포넌트(주키퍼)에 저장되어 있으나,<br>
성능 효율을 높이기 위해 해시 링 사본을 웹소켓 서버에 캐시하는것도 고려해볼 수 있다. 
2. 웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.

**레디스 펍/섭 서버 클러스터의 규모 확장 고려사항**
- 펍/섭 서버는 채널에 대한 상태 정보를 보관한다.<br>
특정 채널을 담당하던 펍/섭 서버를 교체하거나 해시 링에서 제거하는 경우 채널을 다른 서버로 이동시켜야하고<br>
해당 채널의 모든 구독자에게 그 사실을 알려야한다<br>
(왜?? 웹소켓서버에서 구독을 하고있을텐데 해시링만 업데이트되면 되는 것 아닌가? 알린다는것이 해시링의 업데이트를 말하는 것인가?)

**레디스 펍/섭 서버 클러스터의 규모 확장시 문제 발생 가능한 지점**
- 클러스터의 크기 조정시 많은 채널이 같은 해시 링 위의 다른 여러 서버로 이동하게 된다.<br>
이 때 모든 웹소켓 서버에 해시링이 갱신되었음을 알리는데 이 때 엄청난 재구독 요청이 발생할 것이다.(메시지 누락 가능)
- 재구독 요청을 처리하다보면 클라이언트가 보내는 위치 정보 변경 메시지의 처리가 누락될 수 있다.


**운영 고려사항**
- 친구가 많은 사용자 : 몇천명정도의 친구 상한이 있다고 가정하고 생각해보면, <br>
친구를 구독하는데에 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓버서에 분산되어 있을 것이다,<br>
따라서 친구들의 위치변경에서 오는 부하는 각 웹소켓 서버가 나누어 처리할 것이다.

많은 친구를 둔 사용자의 채절이 존재하는 서버의 경우에는 좀 더많은 부하가 있겠지만 해비유저들의 채널이 골고루 분산되어있다고 가정하면 부담이 크지 않다.

- 주변의 임의 사용자 : 주변의 임의 사용자를 무작위로 보여주도록 하는 구현사항이 있을 수 있다.<br>
기존 설계안을 크게 훼손시키지 않으면서 기능을 구현하는 방법으로 지오해시에 따라 구축된 펍/섭 채널 풀을 둘 수 있다.<br>
지역을 지오 해시 격자로 나누고, 격자마다 채널을 하나씩 만들어서 해당 위치에 있는 사용자가 그 채널을 구독하면 된다. <br><br>격자로 나누더래도 모서리 부분에 위치한 사용자가 있을 수 있으니 위치한 지오해시격자뿐만 아니라 주변 8개의 격자도 구독하게 할 수 있다.

**레디스 펍/섭 대안**<br>
얼랭을 사용할 수 있다.<br>
얼랭은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경이다

얼랭 프로세스 생성 비용은 리눅스 프로세스 생성 비용에 비해 매우 저렴한데,<br>
작은 얼랭 프로세스는 300바이트 정도의 메모리만 사용하며 아무 일도 하지 않는 얼랭 프로세스는 CPU자원을 전혀 소모하지 않는다.

천만명에 달하는 활성 사용자 각각을 얼랭 프로세스로 모델링 할 수 있고 그 비용도 매우 저렴하다. 