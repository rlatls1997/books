# 11장. 결제 시스템
결제시스템 설계

## 1단계: 문제 이해 및 설계 범위 확정
요구사항 축소
- 아마존과 같은 전자상거래 애플리케이션을 위한 걸제 백엔드를 구축
- 신용카드 결제만 처리
- 신용카드 결제처리는 전문 결제 서비스 업체를 사용
- 하루 100만건의 거래
- 매월 판매자에게 대금 지급
- 결제시스템은 많은 내외부 서비스와 연동하므로 서비스간 상태불일치를 막기 위해 조정작업을 수행하고 불일치하는 부분이 있으면 교정 필요

**기능 요구사항**
- 대금 수신(pay-in) 흐름 : 결제 시스템이 판매자를 대신하여 고객으로부터 대금을 수령
- 대감 정산(pay-out) 흐름 : 결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송금

**비기능 요구사항**
- 신뢰성 및 내결함성 : 결제 실패는 신중하게 처리해야함
- 내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 제공업체)간의 조정 프로세스 : 시스템간의 결제정보가 일치하는지 비동기적으로 확인함.

**개략적인 규모 추정**
</br>하루에 100만건의 트랜잭션을 처리해야함. 대충 10TPS
</br>10TPS는 일반적은 데이터베이스로 문제없이 처리가능하므로 처리 대역폭보단 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행해야한다.


## 2단계: 개략적 설계안 제시 및 동의 구하기
결제흐름은 크게 두 단계로 세분화된다.
- 대금 수신 흐름
- 대금 정산 흐름

구매자가 주문을 하면 아마존의 계좌로 돈이 들어온다 -> 대금수신흐름
</br>아마존 계좌에 묶여 있던 판매대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급된다 -> 대금정산흐름

### 1. 대금 수신 흐름
대금 수신 흐름의 개략적인 다이어그램.

<img src="https://github.com/rlatls1997/books/assets/62635664/27d63e39-27a4-444c-9951-4fca4cbab79e" width="800">

**결제 서비스**
</br>결제 서비스는 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다.
</br>먼저 AML/CFT(자금세탁방지제도) 와 같은 규약에 따라 위험 점검을 한다.
</br>위험 확인 서비스는 매우 복잡하고 고도로 전문화된 영역이라 제 3자 제공업체를 이용한다.

**결제 실행자**
</br>결제 실행자는 결제 서비스 공급자(PSP)를 통해 결제 주문 하나를 실행한다.
</br>하나의 결제 이벤트에는 여러 결제 주분이 포함될 수 있다.

**결제 서비스 공급자**
</br>결제 서비스 공급자는 A계정에서 B계정으로 돈을 옮기는 역할을 담당한다.
</br>ex) 구매자의 신용카드 계좌에서 돈을 인출하여 아마존 계좌로 입금

**카드 유형**
</br>신용카드 업무를 처리하는 조직.
</br>비자, 마스터카드 등...

**원장(ledger, 자산 부채 등 자본상태 등을 전부 기록한 장부)**
</br>원장은 결제 트랜잭션에 대한 금융 기록이다.
</br>원장 시스템은 총 수익을 계산하거나 향후 수익 예측 등 결제 후 분석에서 중요한 역할을 한다.

**지갑**
</br>지갑에는 판매자의 계정 잔액을 기록한다.

**결제 흐름**
1. 사용자가 `주문하기` 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송된다.
2. 결제 서비스는 결제 이벤트를 데이터베이스에 저장한다.
3. 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있다.(한 번의 결제로 여러 판매자의 제품을 처리하는 경우)
   </br>이런 경우, 결제서비는 결제 주문마다 결제 실행자를 호출한다.
4. 결제 실행자는 결제 주문을 데이터베이스에 저장한다.
5. 결제 실행자가 외부 PSP를 호출하여 신용카드 결제를 처리한다.
6. 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신하여 특정 판매자의 잔고를 기록한다.
7. 지갑 서버는 갱신된 잔고 정보를 데이터베이스에 저장한다.
8. 지갑서비스가 판매자 잔고갱신에 성공하면 결제서비스는 원장을 호출한다.
9. 원장 서비스는 새 원장 정보를 데이터베이스에 추가한다.

**결제 서비스 API**
</br>결제섭비스는 RESTful API 설계규칙을 사용한다.

**POST /v1/payments**
</br>결제 이벤트를 실행하는 엔드포인트.
</br>하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있다.
</br>요청 매개변수는 아래와 같다.

| 필드               | 설명                       | 자료형    |
|------------------|--------------------------|--------|
| buyer_info       | 구매자 정보                   | json   |
| checkout_id      | 해당 결제 이벤트를 식별하는 전역적으로 고유한ID    | string |
| credit_card_info | 암호화된 신용카드정보. PSP마다 다른 값. | json   |
| payment_orders   | 결제 주문 목록                 | list   |

payment_orders는 다음 형태를 띤다.

| 필드               | 설명                      | 자료형    |
|------------------|-------------------------|--------|
| seller_account   | 대금을 수령할 판매자             | string |
| amount           | 해당 주문으로 전송되어야 할 대금      | string |
| currency         | 주문에 사용된 통화 단위           | string  |
| payment_order_id | 해당 주문을 식별하는 전역적으로 고유한ID | string  |


`amount`필드의 데이터 유형이 `double`이 아닌 `string`이라는 것도 중요하다.
</br>`double`자료형이 적합하지 않은 이유는..
1. 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있다. 이러한 차이가 의도치않은 반올림 오류를 유발할 수 있다.
2. `amount`필드는 매우 크거나 매우 작을수도 있다.

따라서 전송 및 저장시엔 숫자는 문자열로 보관하고 표시하거나 계산에 쓸때만 숫자로 변환하는것이 좋다.

**GET /v1/payments/{:id}**
</br>payment_order_id가 가리키는 단일 결제 주문의 실행 상태를 반환한다.

**결제 서비스 데이터 모델**
</br>결제 서비스에는 결제 이벤트, 결제 주문 정보를 저장할 테이블 두 개가 필요하다
</br>결제 시스템용 저장소 솔루션을 고를때 성능은 가장 중요한 고려사항은 아니다.

다음 사항을 중점에 둔다
1. 안전성이 검증되었는가?
2. 모니터링 및 데이터 조사에 필요한 도구가 풍부하게 지원되는가?
3. 해당 솔루션의 DBA 채용시장이 풍부한가?

일반적으로는 NoSQL/NewSQL(NoSQL의 스케일용이함(scalabinity), RDB의 강한 일관성(ACID)을 가짐, ex)구글의 Spanner)보다는 ACID트랜잭션을 지원하는 전통적인 RDBMS를 선호한다.


결제이벤트 테이블에는 자세한 결제 이벤트 정보가 저장된다.

<img src="https://github.com/rlatls1997/books/assets/62635664/3af391ed-227e-4870-a264-76caf8d068fd" width="500">

결제 주문 테이블에는 각 결제 주문의 실행 상태가 저장된다.

<img src="https://github.com/rlatls1997/books/assets/62635664/740d9e52-2a24-4525-b0d8-094f7a83601f" width="500">

- `결제주문 테이블`의 `checkout_id`는 외래키이다. 하나의 결제 이벤트에는 여러 개의 결제 주문이 포함될 수 있다.

DB업데이트 흐름은...
- 결제서비스의 응답 결과에 따라 `payment_order_status`를 설정한다.
- 결제서비스 호출에 성공하면 지갑서비스를 호출하여 판매자 잔액을 업데이트하고 `wallet_updated`필드를 TRUE로 업데이트한다.
- 지갑서비스 업데이트에 성공하면 원장서비스를 호출하여 원장 데이터베이스의 `ledger_updated`필드를 TRUE로 갱신한다
- 동일한 `checkout_id`아래의 모든 결제 주문이 성공적으로 처리되면 `결제이벤트 테이블`의 `is_payment_done`를 TRUE로 업데이트한다.

**복식부기 원장 시스템**
</br>원장시스템에는 복식부기(double-entry)라는 중요한 설계원칙이 있다.
복식부기는 결제시스템에서 필수요소이며 정확한 기록을 남기는데 핵심적인 역할을 한다.

용어에 대해 간략한 설명..
- 부기 : 거래를 일정한 원칙에 따라 자산, 부채, 자본, 비용 등으로 구분하여 장부에 기록하는 행위
- 단식부기 : 가계부나 현금출납장같이 현금 흐름을 위주로 거래를 기록하는 방법
- 복식부기 : 거래를 대차평균의 원리에 따라 차변과 대중에 이중으로 기록하는 방법으로 현금의 흐름뿐만 아니라 원인에 대해서도 기록하는 방법
  - 차변 : 부기에서 계정계좌의 왼쪽. 자산의 증가, 부채 또는 자본의 감소, 손실을 기록하는 부분
  - 대변 : 계정계좌의 오른쪽. 자산의 감소, 부채나 자본의 증가, 이익을 기록하는 부분
  - 대차평균의 원리 : 복식회계에서 양 변을 의미하는 차변과 대변의 값이 일치해야한다는 원리

결론은...
</br>복식부기 시스템에서 모든 거래 항목의 합계는 0이어야한다.
</br>복식부기 원장 시스템을 잘 활용하면 자금 흐름을 시작부터 끝까지 추적할 수 있으며 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

**외부 결제 페이지**
</br>대부분의 기업에선 신용카드 정보를 내부에 저장하지 않는다.(규정을 준수하기가 빡세서)
</br>신용카드 정보를 취급하지 않기 위해 PSP에서 제공하는 외부 신용카드 페이지를 사용한다.

즉, PSP가 제공하는 외부 결제 페이지가 직접 5고객 카드 정보를 수집한다.

### 2. 대금 정산 흐름
대금 정산 흐름의 구성요소는 대금 수신 흐름과 아주 유사하다
</br>차이는, 정산흐름에서는 타사 정산 서비스를 이용하여 웹사이트 은행계좌에서 판매자 은행 계좌로 돈을 이체한다는 점이다.

## 3단계: 상세설계
시스템을 더 빠르고 강력하며 안전하게 만드는데 집중해본다.
</br>다음 주제에 대해 살펴본다
- PSP연동
- 조정
- 결졔 지연 처리
- 내부 서비스 간 통신
- 걸제 실패 처리
- `정확히 한 번`전달
- 일관성
- 보안

**PSP 연동**
대부분 다음 두가지 방법으로 결제시스템을 PS와 연동한다
1. 회사가 민감한 결제정보를 안전하게 저장할 수 있다면 API를 통해 PSP와 연동하는 방법을 택할 수 있다.
   </br>회사가 결제 페이지를 개발하고 민감한 결제정보를 수집하며, PSP는 은행연결, 카드유형 지원 등의 역할을 한다.
2. 복잡한 규정, 보안문제로 민감한 결제 정보를 저장하지 않기로 결정한 경우 PSP는 카드 결제 세부 정보를 수집하며 PSP에 안전하게 저장할 수 있도록 외부 결제 페이지를 제공한다
   </br>대부분이 택하는 방법이다.

외부 결제 페이지 이용 흐름은 다음과 같다.

<img src="https://github.com/rlatls1997/books/assets/62635664/232900cd-2014-4ffe-b2ea-e560ef3ba890" width="800">


1. 사용자가 브라우저에서 `결제`버튼 클릭 결제서비스를 호출한다.
2. 결제서비스는 결제 등록 요청을 PSP로 전송한다. 이때 결제 주문이 정확히 한번만 등록될 수 있도록 UUID필드를 둔다.
3. PSP는 결제 서비스에 토큰을 반환한다. 토큰으로 결제 등록 및 결제 실행 상태를 확인할 수 있다
4. 결제서비스는 외부결제페이지를 호출하기 전에 토큰을 DB에 저장한다.
5. PSP가 제공하는 외부 결제 페이즈를 표시한다. 일반적으로 이를 위해 PSP SDK를 연동한다.
</br>이로 인해 민감한 결제정보는 우리 시스템으로 절대 넘어오지 않는다.
   </br></br>결제페이지에서는 다음 정보가 필요하다.
    1. 토큰 : 4단계에서 받은 토큰으로 결제 요청에 대한 상세정보를 검색하여 사용자에게 받을 금액을 알아내야한다.
    2. redirection url : 결제가 완료되면 호출될 웹페이지 url
6. 사용자는 결제 세부 정보를 입력한 다음 결제 버튼을 클릭한다.
7. PSP가 결제 상태를 반환한다.
8. 사용자는 redirection url이 가리키는 페이지로 이동한다.
9. 비동기적으로는 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출한다. 결제시스템이 웹훅을 통해 결제 이벤트를 다시 수신하면 결제 상태를 추출하여 결제상태필드(payment_order_status)를 최신상태로 업데이트한다.


외부 결제 페이지가 잘 작동할때 시스템들이 상호 연동하는 방식을 설명했다.
</br>하지만 위 단계를 진행중에 네트워크 문제로 실패할 수도 있다.
</br>장애가 발생하면 체계적으로 처리할수 있는 방법이 필요하다. -> 조정

**조정**
관련 서비스간의 상태를 주기적으로 비교하여 일치하는지 확인할 수 있다.

PSP나 은행은 고객에게 주기적으로 정산 파일을 보낸다.
</br>정산 파일에는 은행 계좌의 잔액과 매일 해당 계좌에서 발생한 모든 거래 내역이 기재되어 있다.

조정 시스템은 정산 파일의 세보 정보를 읽어 원장 시스템과 비교한다

<img src="https://github.com/rlatls1997/books/assets/62635664/86cc9c88-8ea4-431d-a23b-8207069a49ad" width="800">

조정은 결제 시스템의 내부 일관성을 확인핼때도 사용된다.(ex, 원장과 지갑의 상태가 같은지)

조정중에 발견된 차이는 수동으로 고치게 된다.

발생가능한 불일치 문제 및 해결방안은 다음 세가지 범주로 나눌 수 있다.
1. 어떤 유형의 문제인지 알고 있으며 문제 해결 절차를 자동화할 수 있는 경우 : 자동화 프로그램을 작성하는 것이 비용 효율적임. 엔지니어가 발생한 불일치 문제의 분류와 조정 작업을 모두 자동화할 수 있음.
2. 어떤 유형의 문제인지는 알지만 문제 해결 절차를 자동화할 수 없는 경우 : 해결 방법을 알고 있지만 자동 조정 프로그램의 작성 비용이 너무 높음. 발생한 불일치문제를 작업대기열에 넣어 재무팀에서 수동으로 수정하도록 해야함
3. 분류할 수 없는 유형의 문제인 경우 : 특별 작업 대기열에 넣고 재무팀에서 조사하도록 한다.


**결제 지연 처리**
</br>결제 요청은 많은 컴포넌트를 거치며 내부 및 외부의 다양한 처리 주체와 연동된다.
</br>완료나 거부되기까지 몇시간보다 더 걸리는 경우다 있다.

결제요청이 평소보다 더 오래 걸리는 사례로는...
- PSP가 해당 결제 요청의 위험성이 높다고 보고 담당자 검토를 요구하는 경우
- 신용카드사가 구매 확인 용도로 카드 소유자의 추가 보호 장치를 요구하는 경우

결제서비스는 처리하는데에 시간이 오래걸리는 이런 요청도 처리할 수 있어야한다.
</br>구매페이지가 외부 PSP에 호스팅되는 경우 PSP는 다음과 같이 처리한다.

- PSP는 결제가 대기 상태임을 알리는 상태 정보를 클라이언트에 반환하고 클라이언트는 이를 사용자에게 표시한다.
- PSP는 우리 회사를 대신하여 대기중인 결제의 진행 상황을 추적하고 상태가 바뀌면 PSP에 등록된 웹훅을 통해 결제서비스에 알린다.

결제 요청이 최종적으로 완료되면 PSP는 사전에 등록된 웹훅을 호출한다.

웹훅을 통해 결제서비스에 결제상태 변경을 알리는 PSP가 있는 반면 결제 서비스로 하여금 대기중인 결제 요청의 상태를 주기적으로 polling하도록 하는 PSP도 있다.

**내부 서비스 간 커뮤니케이션**
</br>내부서비스간에는 동기식, 비동기식 두가지 패턴이 있다.


**동기식 통신**
</br>HTTP같은 동기식 통신은 소규모 시스템에서는 잘 동작하나 규모가 커지면 단점이 명확해진다.

- 성능 저하
- 장애 격리 곤란 : PSP등의 서비스에 장애가 발생하면 클라이언트는 응답을 받지 못함
- 높은 결합도 : 요청 발신가는 수신자를 알아야한다.
- 낮은 확장성 : 갑작스런 트래픽 증가에 대응할 수 옸도록 시스템을 확장하기 어렵다.


**비동기 통신**
</br>비동기 통신은 크게 두 가지 범주로 나눌 수 있다.

- 단일 수신자 : 각 요청은 하나의 수신자 또는 서비스가 처리한다. 일반적으로 공유 메시지 큐를 사용해 구현한다.
  </br>큐에는 복수의 구독자가 있을 수 있으나 처리된 메시지는 큐에서 바로 제거된다.
  <img src="https://github.com/rlatls1997/books/assets/62635664/73736b6a-372a-464d-a6e7-3b04a95c8600" width="600">

  
- 다중 수신자 : 각 요청은 여러 수신자 또는 서버가 처리한다. 카프카에서는 소비자가 수신한 메시지가 바로 사라지지 않기때문에 이런 시나리오를 잘 처리할 수 있다.
  </br>이는 결제시스템 구현에 적합한데, 하나의 요청이 알림 전송, 재무보고 업데이트, 분석결과 업데이트 등 다양한 용도에 쓰일 수 있기 때문이다.

  <img src="https://github.com/rlatls1997/books/assets/62635664/48abc52d-eeb8-4a78-8e90-1516ded4d102" width="600"/>

동기식 통신이 설계는 쉬우나 서비스의 자율성을 높이기에는 부적합하다. 

비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제시스템에는 비동기 통신이 더 나은 선택이다.

**결제 실패 처리**
</br>모든 결제 시스템은 실패한 결제를 적절히 처리할 수 있어야 한다.
</br>안전성 및 결함 내성은 결제 시스템의 핵심적 요구사항이다.

이 문제를 해결하는 기법을 알아보자

**결제 상태 추적**
</br>결제 주기의 모든 단계에서 결제 상태를 정확하게 유지하는 것은 매우 중요하다.
</br>실패가 일어날때마다 결제 거래의 현재 상태를 파악하고 재시도 또는 환불이 필요한지 여부를 결정한다.

**재시도 큐 및 실패 메시지 큐**
실패를 우아하게 처리하기 위해 재시도 큐와 실패 메시지 큐를 두는 것이 바람직하다.

- 재시도 큐 : 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보낸다
- 실패 메시지 큐 : 반복적으로 처리에 실패한 메시지를 보낸다. 이 큐는 메시지를 디버깅하고 격리하여 송공적으로 처리되지 않은 이유를 파악하기 위한 검사에 유용하다.

**정확히 한 번만 절달**
</br>결제 시스템에 발생 가능한 가장 심각한 문제 중 하나는 고객에게 이중으로 청구하는 것이다.
</br>결제가 정확히 단 한번만 실행되도록 설계하는것이 중요하다.

재시도를 통한 최소 한 번 실행을 보증하는 방법과,
</br>멱등성 검사를 통해 최대 한 번 실행을 보증하는 방법을 알아보자

**재시도**
</br>네트워크 오류나 시간초과로 재시도를 해야하는 경우가 있다.
</br>재시도 메커니즘을 도입할때는 얼마나 간격을 두고 재시도할지 정하는 것이 중요하다.

일반적으로 사용되는 전략은 다음과 같다
- 즉시 재시도(immediate retry)
- 고정 간격(fixed interval)
- 증분 간격(incremental interval) : 재시도 전에 기다리는 시간을 특정한 양 만큼 점진적으로 늘려나가는 방안
- 지수적 백오프(exponential backoff) : 재시도 전에 기다리는 시간을 직전 재시도 대비 두배씩 늘려나가는 방안, 1, 2, 4, 8 ....
- 취소 : 요청을 철회하는 방안. 실패가 영구적이거나 재시도해도 성공가능성이 낮은 경우 사용

일반적으로 적용 가능한 지침은, 네트워크 문제가 단시간 내에 해결되지 않을것같다면 지수적 백오프를 사용하는 것이 좋다.
</br>그리고 요청에 실패해서 사용자가에 에러코드를 반환할때는 Retry-After 헤더를 같이 붙여서 보내는 것이 바람직하다.

재시도시 발생할 수 있는 문제로는 이중 결제가 있다.
</br>시나리오를 생각해보면...
1. 결제시스템이 외부 결제 페이지를 통해 PSP와 연동하는 환경에서 클라이언트가 결제 버튼을 두번 중복 클릭한다.
2. PSP가 결제를 성공적으로 하였으나 네트워크 오류로 인해 응답이 결제 시스템이 도달하지 못하여 결제 를 재시도한다.

이중 결제를 막기 위해 결제는 최대 한 번 이루어져야 한다.
</br>이를 위해 결제요청은 멱등성(연산이 한 번 적용되든 여러번 적용되든 결과가 동일한 성질)을 지녀야한다.

**멱등성**
</br>클아이언트와 서버간의 통신을 위해서는 일반적으로 고유한 값을 멱등키로 사용한다.
</br>많은 PSP에서는 UUID를 멱등키로 권장한다.(PSP에서 받은 난수 토큰을 HTTP헤더에 넣어서 이중결제 문제를 해결)

**일관성**
</br>결제 실행 과중 중 상태 정보를 유지관리하는 여러 서비스가 호출된다.
- 결제서비스는 난수, 토큰, 결제주문, 실행상태 등 결제 관련 데이터를 유지관리
- 원장은 모든 회계 데이터를 보관
- 지갑은 판매자의 계정 잔액을 유지
- PSP는 결제 실행상태를 유지
- 데이터는 안정성 증가를 위해 여러 데이터베이스 사본에 복제될 수 있다

분산환경에서는 서비스간 통신 실패로 데이터 불일치가 발생할 수 있다.

내부서비스간의 데이터 일관성을 유지하려면, 정확히 한번만 처리되도록 보장되어야 한다.

내부서비스와 외부서비스(PSP)간의 데이터 일관성 유지를 위해서는, 멱등성과 조정 프로세스가 필요하다.
</br>결제를 재시도할때는 같은 멱등키로 멱등 API를 호출해야한다.
</br>멱등 API를 지원하더라도 외부 시스템이 항상 옳다고 가정할 수는 없으므로 조정 절차가 필요하다.

데이터를 다중화하는 경우에는, 복제지연으로 사본 데이터와 불일치하는 일이 발생할 수 있다.
이 문제의 해결방안으로는
1. 주 데이터베이스에서는 읽기와 쓰기 연산을 처리한다. 이 방법은 설정은 쉬우나 규모 확장성이 떨어진다.
   </br>사본은 데이터 안정성 보장에만 활용하고 트래픽은 처리하지 않는다. 따라서 자원이 낭비된다.

2. 모든 사본이 항상 동기화되도록 한다.

**결제 보안**
</br>결제보안은 매우 중요하다.
</br>사이버 공격, 카드 도난에 대응하기 위한 다음 기술이 있다.

| 문제                 | 해결책                                     |
|--------------------|-----------------------------------------|
| 요청/응답 도청           | HTTPS사용                                 |
| 데이터 변조             | 암호화 및 무결성 강화 모니터링                       |
| 중간자공격              | 인증서 고정과 함께 SSL 사용                       |
| 데이터 손실             | 데이터베이스 복제 및 스냅샷 생성                      |
| 분산 서비스 거부 공격(DDos) | 처리율 제한 및 방화벽                            |
| 카드 도난              | 토큰화. 실제 카드 번호를 사용하지 않고 결제에 토큰을 사용함      |
| PCI 규정 준수          | PCI DSS는 브랜드 신용 카드를 처리하는 조직을 위한 정보보안 표준 |
| 사기 | 주소확인, 카드확인번호(CVV), 사용자 행동분석 등 |





