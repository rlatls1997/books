# Chapter 4. 스트림 소개
**내용**

- 스트림이란 무엇인가?
- 컬렉션과 스트림
- 내부 반복과 외부 반복
- 중간 연산과 최종 연산

스트림을 통해 컬렉션 처리를 쉽고 단순하게 다룰 수 있다.

## 4.1 스트림이란 무엇인가?

**스트림**

자바 8 API에 새로 추가된 기능.

스트림을 이용하면 선언형(데이터를 처리하는 임시 구현 코드 대신 질의로 표현)으로 컬렉션 데이터를 처리할 수 있다. 스트림을 이용하여 데이터 컬렉션 반복을 깔끔하게 처리할 수 있다.

또한 스트림을 사용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

- 자바 7 코드

```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish : menu){
	if(dish.getCalories() < 400){
		lowCaloricDishes.add(dish);
	}
}

Collections.sort(lowCaloricDishes, new Comparator<Dish>(){
	public int compare(Dish dish1, Dish dish2){
		return Integer.compare(dish1.getCalories(), dish2.getCalories());
	}
});

List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish : lowCaloricDishes){
	lowCaloricDishesName.add(dish.getName());
}
```

- 자바 8 코드

```java
List<String> lowCaloricDishesName = menu.stream()
	.filter(d -> d.getCalories() < 400)
	.sorted(comparing(Dish::getCalories))
	.map(Dish::getName)
	.collect(toList());
```

여기서 stream()을 parallelStream()으로 바꾸면 이 코드를 멀티코어 아키텍쳐에서 병렬로 실행할 수 있다.

위와 같이 스트림을 사용하여 다음의 이득을 얻을 수 있다.

- 선언형으로 코드를 구현할 수 있다. 즉 제어블록에서 어떻게 동작을 구현할 것인지 지정할 필요 없이 ‘저칼로리의 요리만 선택하라’같은 동작의 수행을 지정할 수 있다.
- 여러 연산들에서의 복잡한 데이터 처리를 파이프라인으로 만들 수 있다.

filter, sorted, map 등의 연산은 **고수둔 빌딩 블록**으로 이루어져 있으므로 특정 스레딩 모델에 제한되지 않고 자유롭게 어떤 상황에서든 사용할 수 있다.

스트림 API는 매우 비싼 연산이다.(왜인지 6장에서 설명)

## 4.2 스트림 시작하기

숫자범위나 I/O 자원 등 다양한 방법으로 스트림을 얻을 수 있다.

스트림이란 ‘데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소’

- 연속된 요소
  컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션은 자료구조이므로 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다.

  반면 스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룬다. 즉 컬렉션의 주제는 데이터이고 스트림의 주제는 계산이다.

- 소스
  스트림은 컬렉션, 배열 등의 데이터 제공 소스로부터 데이터를 소비한다. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
- 데이터 처리 연산
  스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다. filter, map, reduce ...

스트림에는 다음과 같은 두 가지 중요 특징이 있다.

- 파이프라이닝
  스트림 연산은 스트림 연산끼리 연결하여 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다. 이 덕에 게으름, 쇼트서킷 같은 최적화도 얻을 수 있다.
- 내부 반복
  반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부반복을 지원한다.

ex)

```java
List<String> threeHighCaloricDishNames = 
	menu.stream() // 스트림 생성
		.filter(dish -> dish.getCalories() > 300)  // 필터링
		.map(Dish::getName)  // 요리명 추출
		.limit(3)            // 선착순 세 개 선택
		.collect(toList());  // 결과를 다른 리스트로 저장
```

데이터 소스 = 메뉴
데이터 처리 연산 = filter, map

collect를 제외한 모든 연산은 서로 파이프라인을 형성할 수 있도록 다시 스트림을 반환한다.

## 4.3 스트림과 컬렉션

자바의 기존 컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. ‘연속된’의 의미는 순서가 있는, 순차적으로 값에 접근한다는 것을 의미한다.

데이터를 언제 계산하느냐

컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
컬렉션은 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조이다. 즉 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.

반면 스트림은 요청할 때만 요소를 계산하는 고정된(요소의 추가, 제거가 불가능한) 자료구조이다. 사용자가 요청하는 값만 스트림에서 추출한다.

스트림은 게으르게 만들어지는 컬렉션과 같다. 즉 사용자가 데이터를 요청할 때만 값을 계산한다.(요청 중심 제조, 즉석 제조).
반면 컬렉션은 적극적으로 생성된다(생산자 중심, 팔기도 전에 재고 먼저 쌓음)

컬렉션과 스트림을 비교하면

컬렉션은 DVD 파일 내용 전부가 로드된 뒤 재생이 되는 방식.
스트림은 일부가 로드될 때마다 바로 재생되는 영상 스트리밍 방식

### 1. 딱 한 번만 탐색할 수 있다.

반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다. 즉 탐색된 스트림 요소는 소비된다.

```java
Stream<String> s = title.stream();

s.forEach(System.out::println); // 출력 가능
s.forEach(System.out::println); // 스트림이 이미 소비되었거나 닫힘/ IllegalStateException
```

### 2. 외부 반복과 내부 반복

컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.(for-each등을 사용하여) 이를 **외부 반복**이라고 한다. 반면 스트림 라이브러리는 **내부 반복**(반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는)을 사용한다.

스트림 라이브러리 내부반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다. 반면 for-each를 이용하는 외부 반복에서는 병렬성을 스스로 관리해야한다.

## 4.4 스트림 연산

중간 연산 : 연결할 수 있는 스트림을 다시 반환하는 연산

최종 연산 : 스트림을 닫는 연산

### 1. 중간 연산

filter, sorted등 중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 사용해서 질의를 만들 수 있다. 중간 연산으로 합쳐진 결과를 최종 연산으로 한 번에 처리하기 때문에 스트림을 게으르다고 표현한다.

```java
List<String> names = menu.stream()
	.filter(dish ->{
		System.out.println("filtering")
		return dish.getCalories() > 300;
	})
	.map(dish -> {
		System.out.println("mapping")
		return ...
	})
	.limit(3)
	.collect(toList());

출력
filtering
mapping
filtering
mapping
filtering
mapping
```

스트림의 게으른 특성 덕분에 몇 가지 최적화 효과를 얻을 수 있다.

limit 연산을 통해 여러개의 데이터 중 중간연산을 통과한 3개의 데이터만 얻는다. 이를 **쇼트서킷**이라 부른다.
filter, map은 서로 다른 연산이지만 한 개의 과정으로 병합되었다. 이를 **루프 퓨전**이라고 한다.

### 2. 최종 연산

최종연산을 통해 스트림 파이프라인의 결과를 도출한다. 보통 List, Integer 등 스트림 외의 결과가 반환된다.

### 3. 스트림 이용하기

스트림 이용 과정

- 질의를 수행할 데이터 소스
- 스트림 파이프라인을 구성할 중간 연산 연결
- 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

마치 빌더패턴과 유사하다.

## 5. 로드맵

예제 외의 다양한 연산이 존재한다.

5장에서.

## 6. 마치며

- 스트림은 소스에서 추출된 연속 요소. 데이터 처리 연산을 지원한다.
- 스트림은 내부 반복을 지원한다. 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화한다.
- 스트림은 중간연산과 최종연산으로 이루어져있다.
- 중간연산은 스트림을 반환하여 다른 연산과 이어질 수 있는 연산이다. 파이프라인을 구성할 수 있지만 결과를 생성할 순 없다.
- 최종연산은 스트림 파이프라인을 처리하여 결과를 반환할 수 있다.
- 스트림의 요소는 요청할 때 게으르게 계산된다.