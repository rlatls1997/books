# Chapter 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
## 내용

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 기능소개

# 1. 역사의 흐름이란 무엇인가?

자바 8에서 자바 역사 중 가장 큰 변화가 일어남.

지금까지의 대부분의 자바 프로그램은 코어 중 하나만을 사용했다. 나머지 코어는 유휴상태로 두거나 다른 프로그램들과 프로세스 파워를 나눠서 사용했다.

자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공.
자바 9에서는 리액티브 프로그래밍이라는 병렬 실행 기법을 지원.

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반으로 한다.
자바 8에서는 다음의 새로운 기능을 제공한다

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

# 2. 왜 아직도 자바는 변화하는가

## 2.1 프로그래밍 언어 생태계에서 자바의 위치

수많은 유용한 라이브러리를 포함한 잘 설계된 객체 지향 언어로 시작.
자바의 첫 모습

- 스레드와 락을 이용한 동시성 지원
- 코드를 JVM바이트 코드로 컴파일( 모든 브라우저에서 가상 머신 코드를 지원 ⇒ 인터넨 애플릿 프로그램의 주요 언어가 됨 )
- 다양한 임베디드 컴퓨팅 분야 장악

1990년대 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링 적인 문제가 훨씬 적고 객체지향 모델 덕분에 윈도우 95 및 그 이후의 WIMP(?) 프로그래밍 모델에 쉽게 대응할 수 있어서 대중적인 언어로 발돋음.

## 2.2 스트림 처리

스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임.

스트림 동작을 자동차 공장을 예시로 들면,
자동차 공장에서는 여러 자동차로 구성된 스트림을 처리하는데 각 작업장에서는 맡은 공정을 마치고 다음 작업장으로 넘겨준다. 각 작업장 단위로 보면 한 번에 한 대의 자동차를 수리하지만 모든 작업장을 기준으로 보면 동시에 여러대의 작업을 처리한다. ( 컨베이어벨트 느낌)

자바 8에는 [java.util.stream](http://java.util.stream) 패키지에 스트림 API가 추가되었음

기존에는 한 번에한 항목을 처리했던 반면 자바 8에서는 작업을 일련의 스트림으로 만들어서 처리할 수 있음. 또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있는 이점도 있음.  ⇒ 복잡한 작업을 하지 않으면서 병렬성을 얻을 수 있다.

## 2.3 동작 파라미터화로 메서드에 코드 전달하기

두 번째로 자바 8에서는 코드 일부를 API로 전달하는 기능이 추가됨.

만약 우리가 지정하는 순서대로 자료를 정렬하기위해 sort메서드를 사용하려고 한다면 해당 특정값의 정렬 기준을 sort메서드에 제공해야 한다. 이를 위해 Comparator 객체를 만들어서 sort에 넘겨줄 수 있지만 너무 복잡하며 기존 동작을 단순하게 재활용한다는 측면에서도 맞지 않다.

자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이 기능을 **동작 파라미터화**라고 한다.

정렬을 하기위해 기준원소의 비교연산을 sort의 인수로 넘겨주는 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달할 수 있다.

## 2.4 병렬성과 공유 가변 데이터

세 번째로 자바 8에서는 병렬성을 공짜로 얻을 수 있다.

병렬성을 얻기 위해서는 스트림 메서드로 전달하는 코드의 동작 방식을 수정해야한다. 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.

다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다. 이러한 함수를 **순수함수** 라고 부른다.

synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있지만 시스템 성능에 좋지 않고 번거롭다(또 synchronized를 사용하여 가변데이터를 보호하면 다중 처리 코어에서는 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시킴).

자바 8의 스트림을 사용하면 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.

## 2.5 자바가 진화해야 하는 이유

언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야한다.

새롭게 추가된 기능에 관심을 가지면서 프로그래머로서 계속 성장해야 한다.

# 3. 자바 함수

자바 8에서는 함수를 새로운 값의 형식으로 추가했다.
멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.

**함수를 값으로 취급할 때의 이점**

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 프로그래밍 언어에서는 이 값을 일급 값 이라고 부른다. 자바 언어의 다양한 구조체(메서드, 클래스 등)가 값의 구조를 표현하는 데 도움이 될 수 있다.

하지만 이러한 모든 구조체를 프로그램을 실행하는 동안 자유롭게 전달할 수 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다. 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있지만 메서드와 클래스는 값이 될 수 없다.

만약 런타임에 메서드를 전달할 수 있다면? (메서드를 일급 시민으로 만들면)

⇒ 프로그래밍에 유용하게 활용할 수 있다. 자바 8에서 이급 시민을 일급 시민으로 바꿀 수 있는 기능이 추가되었다.

## 3,1 메서드와 람다를 일급 시민으로

**메서드 참조**

자바 8에 추가된 새로운 기능이다.

예를 들어서 디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하면
주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드 필요 ⇒ File 클래스에 isHidden 메서드 사용

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
	public boolean accept(File file) {
		return file.isHidden();
	}
}
```

이렇게 코드를작성할 수 있으나 각 행이 무슨 작업을 하는지 투명하지 않다.
그리고 불필요한 코드로 필요한 메서드를 감싸서 전달해야한다.

자바 8에서는 아래처럼 코드를 구현할 수 있다.

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

자바 8에서는 **메서드 참조** :: (이 메서드를 값으로 사용하라는 의미)를 사용해서 listFiles에 직접 함수를 전달할 수 있다.
이미 isHidden이라는 함수가 준비되어 있으니 이 함수를 사용하라는 의미이다.

기존에 비해 문제를 더 직접적으로 설명할 수 있다.

자바 8에서는 메서드참조를 사용하여코드를 마음대로 전달할 수 있다.

**람다 : 익명 함수**

자바 8에서는 메서드를 **람다(익명함수)**를 포함하여 함수도 값으로 취급할 수 있다.

람다 문법을 사용하면 직접 메서드를 정의하지 않고 로직만 담아낼 수 있어서 더 간결하게 코드를 구현할 수 있다.

## 3.2 코드 넘겨주기 : 예제

Apple 클래스와 getColor 메서드가 있고 Apples 리스트를 포함하는 변수 inventory가 있다고 가정하자. 모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램을 구현하려고 한다. 이렇게 특정 항목을 선택해서 반환하는 동작을 **필터**라고 한다.

자바 8이전이라면 다음과 같은 메서드를 구현했을 것이다.

```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
	List<Apple> result = new ArrayList<>();

	for(Apple apple : inventory){
		if(GREEN.equals(apple.getColor())){
			result.add(apple);
		}
	}
	return result;
}
```

만약 위 동작에서 사과 무게로 필터링하고 싶어진다면 위 코드를 다음과 같이 변경할 수 있다.

```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
	List<Apple> result = new ArrayList<>();

	for(Apple apple : inventory){
		if(apple.getWeight() > 150)){
			result.add(apple);
		}
	}
	return result;
}
```

이러한 코딩의 단점은 수정으로 인해 발생하는 버그가 포함된 모든 코드를 수정해야 한다는 것이다.

이런 문제를 자바 8에서는 조건을 인수로 전달하여 해결할 수 있다.

```java
public static boolean isGreenApple(Apple apple){
	return GREEN.equals.apple.getColor());
}

public static boolean isHeavyApple(Apple apple){
	return apple.getWeight() > 150;
}

// 인수가 함수라는 것을 명확하게 하기 위해 추가
public interface Predicate<T> {
	boolean test(T t);
}
...

public static List<Apple> filterGreenApples(List<Apple> inventory,
																	Predicate<Apple> p){
	List<Apple> result = new ArrayList<>();

	for(Apple apple : inventory){
		if(p.test(apple))){
			result.add(apple);
		}
	}
	return result;
}
```

필터 메서드를 호출할 때에는

```java
filterApples(inventory, Apple::isGreenApple);
```

과 같은 형태로호출하여 필터링할 수 있다.

**프레디케이트(predicate) 란?**

수학에서는 인수로 값을 받아 true or false 값을 반환하는 함수를 프레디케이트라고 한다.

Function<Apple,Boolean> 같이 코드를 구현할 수 있지만 Predicate<Apple>을 사용하는 것이 표준적인 방식이다. (boolean을 Boolean으로 변환하는 과정이 없으므로 더 효율적)

## 3.3 메서드 전달에서 람다로

메서드로 값을 전달하는 것은 유용하지만 한두번만 사용할 메서드를 매번 정의하는 것은 귀찮음.

자바 8에서는 람다를 사용하여 위의 코드를 다음과 같이 구현할 수 있음.

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()) );
```

위와 같이 한 번만 사용하면서도 동작이 단순한  메서드는 따로 정의를 할 필요가 없는 것.

# 4. 스트림

컬렉션에서는 for-each 루프를 이용하여 반복과정을 직접 처리해야 했다.
이러한 방식의 반복을 **외부 반복**이라고 한다.

반면 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이러한 반복을 **내부 반복**이라고 한다.

```java
transactions.stream()
	.filter((Transaction t)-> t.getPrice() > 1000)
	.collect(groupingBy(Transaction::getCurrency));
```

## 4.1 멀티스레딩은 어렵다

이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다. 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.

자바 8의 스트림 API는 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 멀티코어 활용의 어려움이라는 문제를 해결했다.

스트림 API는 데이터를 필터링, 데이터를 추출, 그룹화 등의 기능이 있다.

또한 이러한 동작들을 쉽게 병렬화 할 수 있다.
예를 들어 두 개의 CPU를 가진 환경에서 리스트를 필터링 할 때 한 CPU는 리스트의 앞부분, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청할 수 있다. 이 과정을 **포킹 단계**라고 한다.

각각의 CPU는 자신이 맡은 리스트 부분을 처리하고 마지막으로 하나의 CPU가 두 결과를 정리한다.

- 순차 처리 방식의 코드

```java
List<Apple> heavyApples = inventory.stream().filter((Apple a)-> a.getWeight() >150)
																						.collect(toList());
```

- 병렬 처리 방식의 코드

```java
List<Apple> heavyApples = 
		inventory.parallelStream().filter((Apple a)-> a.getWeight() >150)
															.collect(toList());
```

**자바의 병렬성과 공유되지 않은 가변 상태**

자바의 병렬성은 어렵고 synchronized는 쉽게 에러를 일으킨다. 자바 8에서는 어떻게 이를 해결?

우선 라이브러리에서 분할을 처리한다. 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다. 또한 fulter같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있다.
함수형 프로그래밍에서 함수형이란 ‘함수를 일급값으로 사용한다’라는 의미도 있지만 ‘프로그램이 실행되는 동안 컴포넌트 간에 상호 작용이 일어나지 않는다’라는 의미도 포함된다.

# 5. 디폴트 메서드와 자바 모듈

자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.

디폴트메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.

ex)

```java
List<Apple> heavyApples = inventory.stream().filter((Apple a)-> a.getWeight() >150)
																						.collect(toList());

List<Apple> heavyApples = 
		inventory.parallelStream().filter((Apple a)-> a.getWeight() >150)
															.collect(toList());
```

자바 8 이전에는 List<T>(List가 구현하는 인터페이스인 Collection<T> 또한)가 stream이나 parallelStream 메서드를 지원하지 않았다. 따라서 위 예시코드는 컴파일 할 수 없다.

해결책은 Collection 인터페이스에 stream 메서드를 추가하고 ArrayList 클래스에서 메서드를 구현하는 것이다.

하지만 이 방식은 힘들다.
컬렉션 API의 인터페이스를 구현하는 모든 클래스는 새로 추가된 메서드를 구현해야 한다. 기존의 구현을 고치지 않고 이미 공개된 인터페이스를 변경할 수는 없을까?

이러한 이유로 자바 8에서는 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다. (그래서 디폴트메서드라고 부른다.)

디폴트 메서드를 사용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. 디폴드 메서드의 예시로 자바 8에 추가된 List 인터페이스의 sort가 있다. List를 구현하는 클래스를 수정하지 않아도 된다.

```java
default void sort(Comparator<? super E> c){
	Coolections.sort(this, c);
}
```

# 6. 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

자바에 포함된 함수형 프로그래밍의 핵심적인 아이디어

- 메서드와 람다를 일급값으로 사용하는 것
- 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출

Optional<T> 클래스 : 자바 8에 추가된 NullPointer 예외를 피할 수 있도록 도와주는 클래스

패턴 매칭 : iif-than-else 가 아닌 케이스로 정의하는 것. ex) 정규표현식

# 7. 마치며

- 8버전 이전에서 멀티코어 프로세서를 온전히 활용하는 것은 어렵다.
- 스트림을 잘 활용하자.
- 자바는 영원하지 않다. 코틀린 공부하자.